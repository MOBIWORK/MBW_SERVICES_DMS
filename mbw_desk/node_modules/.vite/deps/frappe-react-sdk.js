import {
  require_react
} from "./chunk-KZA2ZXKF.js";
import {
  __toESM
} from "./chunk-LNEMQRCO.js";

// node_modules/frappe-react-sdk/dist/frappe-react-sdk.es.js
var import_react = __toESM(require_react());
var Hs = Object.defineProperty;
var Js = (n, e, t) => e in n ? Hs(n, e, { enumerable: true, configurable: true, writable: true, value: t }) : n[e] = t;
var De = (n, e, t) => (Js(n, typeof e != "symbol" ? e + "" : e, t), t);
var F = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var rn = {};
var ot = {};
var mt = {};
var ue = F && F.__assign || function() {
  return ue = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, ue.apply(this, arguments);
};
var xt = F && F.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(f) {
      try {
        a(r.next(f));
      } catch (h) {
        o(h);
      }
    }
    function l(f) {
      try {
        a(r.throw(f));
      } catch (h) {
        o(h);
      }
    }
    function a(f) {
      f.done ? i(f.value) : s(f.value).then(c, l);
    }
    a((r = r.apply(n, e || [])).next());
  });
};
var At = F && F.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(f) {
      return l([a, f]);
    };
  }
  function l(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, a[0] && (t = 0)), t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: false };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: true };
  }
};
Object.defineProperty(mt, "__esModule", { value: true });
mt.FrappeCall = void 0;
var Ys = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : false, this.token = s, this.tokenType = i;
  }
  return n.prototype.get = function(e, t) {
    return xt(this, void 0, void 0, function() {
      return At(this, function(r) {
        return [2, this.axios.get("/api/method/".concat(e), { params: t }).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw ue(ue({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n.prototype.post = function(e, t) {
    return xt(this, void 0, void 0, function() {
      return At(this, function(r) {
        return [2, this.axios.post("/api/method/".concat(e), ue({}, t)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw ue(ue({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n.prototype.put = function(e, t) {
    return xt(this, void 0, void 0, function() {
      return At(this, function(r) {
        return [2, this.axios.put("/api/method/".concat(e), ue({}, t)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw ue(ue({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n.prototype.delete = function(e, t) {
    return xt(this, void 0, void 0, function() {
      return At(this, function(r) {
        return [2, this.axios.delete("/api/method/".concat(e), { params: t }).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw ue(ue({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n;
}();
mt.FrappeCall = Ys;
var gt = {};
var K = F && F.__assign || function() {
  return K = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, K.apply(this, arguments);
};
var je = F && F.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(f) {
      try {
        a(r.next(f));
      } catch (h) {
        o(h);
      }
    }
    function l(f) {
      try {
        a(r.throw(f));
      } catch (h) {
        o(h);
      }
    }
    function a(f) {
      f.done ? i(f.value) : s(f.value).then(c, l);
    }
    a((r = r.apply(n, e || [])).next());
  });
};
var qe = F && F.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(f) {
      return l([a, f]);
    };
  }
  function l(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, a[0] && (t = 0)), t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: false };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: true };
  }
};
Object.defineProperty(gt, "__esModule", { value: true });
gt.FrappeDB = void 0;
var Gs = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : false, this.token = s, this.tokenType = i;
  }
  return n.prototype.getDoc = function(e, t) {
    return t === void 0 && (t = ""), je(this, void 0, void 0, function() {
      return qe(this, function(r) {
        return [2, this.axios.get("/api/resource/".concat(e, "/").concat(t)).then(function(s) {
          return s.data.data;
        }).catch(function(s) {
          var i, o;
          throw K(K({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: "There was an error while fetching the document.", exception: (o = (i = s.response.data.exception) !== null && i !== void 0 ? i : s.response.data.exc_type) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n.prototype.getDocList = function(e, t) {
    var r;
    return je(this, void 0, void 0, function() {
      var s, i, o, c, l, a, f, h, g, v, p;
      return qe(this, function(y) {
        return s = {}, t && (i = t.fields, o = t.filters, c = t.orFilters, l = t.orderBy, a = t.limit, f = t.limit_start, h = t.groupBy, g = t.asDict, v = g === void 0 ? true : g, p = l ? "".concat(String(l == null ? void 0 : l.field), " ").concat((r = l == null ? void 0 : l.order) !== null && r !== void 0 ? r : "asc") : "", s = {
          fields: i ? JSON.stringify(i) : void 0,
          filters: o ? JSON.stringify(o) : void 0,
          or_filters: c ? JSON.stringify(c) : void 0,
          order_by: p,
          group_by: h,
          limit: a,
          limit_start: f,
          as_dict: v
        }), [2, this.axios.get("/api/resource/".concat(e), { params: s }).then(function(E) {
          return E.data.data;
        }).catch(function(E) {
          var b, R;
          throw K(K({}, E.response.data), { httpStatus: E.response.status, httpStatusText: E.response.statusText, message: "There was an error while fetching the documents.", exception: (R = (b = E.response.data.exception) !== null && b !== void 0 ? b : E.response.data.exc_type) !== null && R !== void 0 ? R : "" });
        })];
      });
    });
  }, n.prototype.createDoc = function(e, t) {
    return je(this, void 0, void 0, function() {
      return qe(this, function(r) {
        return [2, this.axios.post("/api/resource/".concat(e), K({}, t)).then(function(s) {
          return s.data.data;
        }).catch(function(s) {
          var i, o, c;
          throw K(K({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error while creating the document.", exception: (c = (o = s.response.data.exception) !== null && o !== void 0 ? o : s.response.data.exc_type) !== null && c !== void 0 ? c : "" });
        })];
      });
    });
  }, n.prototype.updateDoc = function(e, t, r) {
    return je(this, void 0, void 0, function() {
      return qe(this, function(s) {
        return [2, this.axios.put("/api/resource/".concat(e, "/").concat(t), K({}, r)).then(function(i) {
          return i.data.data;
        }).catch(function(i) {
          var o, c, l;
          throw K(K({}, i.response.data), { httpStatus: i.response.status, httpStatusText: i.response.statusText, message: (o = i.response.data.message) !== null && o !== void 0 ? o : "There was an error while updating the document.", exception: (l = (c = i.response.data.exception) !== null && c !== void 0 ? c : i.response.data.exc_type) !== null && l !== void 0 ? l : "" });
        })];
      });
    });
  }, n.prototype.deleteDoc = function(e, t) {
    return je(this, void 0, void 0, function() {
      return qe(this, function(r) {
        return [2, this.axios.delete("/api/resource/".concat(e, "/").concat(t)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw K(K({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: "There was an error while deleting the document.", exception: (o = (i = s.response.data.exception) !== null && i !== void 0 ? i : s.response.data.exc_type) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n.prototype.getCount = function(e, t, r, s) {
    return r === void 0 && (r = false), s === void 0 && (s = false), je(this, void 0, void 0, function() {
      var i;
      return qe(this, function(o) {
        return i = {
          doctype: e,
          filters: []
        }, r && (i.cache = r), s && (i.debug = s), t && (i.filters = t ? JSON.stringify(t) : void 0), [2, this.axios.get("/api/method/frappe.client.get_count", { params: i }).then(function(c) {
          return c.data.message;
        }).catch(function(c) {
          var l, a;
          throw K(K({}, c.response.data), { httpStatus: c.response.status, httpStatusText: c.response.statusText, message: "There was an error while getting the count.", exception: (a = (l = c.response.data.exception) !== null && l !== void 0 ? l : c.response.data.exc_type) !== null && a !== void 0 ? a : "" });
        })];
      });
    });
  }, n.prototype.getLastDoc = function(e, t) {
    return je(this, void 0, void 0, function() {
      var r, s;
      return qe(this, function(i) {
        switch (i.label) {
          case 0:
            return r = {
              orderBy: {
                field: "creation",
                order: "desc"
              }
            }, t && (r = K(K({}, r), t)), [4, this.getDocList(e, K(K({}, r), { limit: 1, fields: ["name"] }))];
          case 1:
            return s = i.sent(), s.length > 0 ? [2, this.getDoc(e, s[0].name)] : [2, {}];
        }
      });
    });
  }, n;
}();
gt.FrappeDB = Gs;
var vt = {};
var $t = F && F.__assign || function() {
  return $t = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, $t.apply(this, arguments);
};
var Xs = F && F.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(f) {
      try {
        a(r.next(f));
      } catch (h) {
        o(h);
      }
    }
    function l(f) {
      try {
        a(r.throw(f));
      } catch (h) {
        o(h);
      }
    }
    function a(f) {
      f.done ? i(f.value) : s(f.value).then(c, l);
    }
    a((r = r.apply(n, e || [])).next());
  });
};
var Qs = F && F.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(f) {
      return l([a, f]);
    };
  }
  function l(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, a[0] && (t = 0)), t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: false };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: true };
  }
};
Object.defineProperty(vt, "__esModule", { value: true });
vt.FrappeFileUpload = void 0;
var Zs = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : false, this.token = s, this.tokenType = i;
  }
  return n.prototype.uploadFile = function(e, t, r, s) {
    return s === void 0 && (s = "upload_file"), Xs(this, void 0, void 0, function() {
      var i, o, c, l, a, f, h, g;
      return Qs(this, function(v) {
        return i = new FormData(), e && i.append("file", e, e.name), o = t.isPrivate, c = t.folder, l = t.file_url, a = t.doctype, f = t.docname, h = t.fieldname, g = t.otherData, o && i.append("is_private", "1"), c && i.append("folder", c), l && i.append("file_url", l), a && f && (i.append("doctype", a), i.append("docname", f), h && i.append("fieldname", h)), g && Object.keys(g).forEach(function(p) {
          var y = g[p];
          i.append(p, y);
        }), [2, this.axios.post("/api/method/".concat(s), i, {
          onUploadProgress: function(p) {
            r && r(p.loaded, p.total, p);
          }
        }).catch(function(p) {
          var y, E;
          throw $t($t({}, p.response.data), { httpStatus: p.response.status, httpStatusText: p.response.statusText, message: (y = p.response.data.message) !== null && y !== void 0 ? y : "There was an error while uploading the file.", exception: (E = p.response.data.exception) !== null && E !== void 0 ? E : "" });
        })];
      });
    });
  }, n;
}();
vt.FrappeFileUpload = Zs;
var Ge = {};
function Ur(n, e) {
  return function() {
    return n.apply(e, arguments);
  };
}
var { toString: ei } = Object.prototype;
var { getPrototypeOf: Pn } = Object;
var Ht = /* @__PURE__ */ ((n) => (e) => {
  const t = ei.call(e);
  return n[t] || (n[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var Ee = (n) => (n = n.toLowerCase(), (e) => Ht(e) === n);
var Jt = (n) => (e) => typeof e === n;
var { isArray: Ze } = Array;
var dt = Jt("undefined");
function ti(n) {
  return n !== null && !dt(n) && n.constructor !== null && !dt(n.constructor) && fe(n.constructor.isBuffer) && n.constructor.isBuffer(n);
}
var Ir = Ee("ArrayBuffer");
function ni(n) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && Ir(n.buffer), e;
}
var ri = Jt("string");
var fe = Jt("function");
var jr = Jt("number");
var zt = (n) => n !== null && typeof n == "object";
var si = (n) => n === true || n === false;
var Ut = (n) => {
  if (Ht(n) !== "object")
    return false;
  const e = Pn(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
};
var ii = Ee("Date");
var oi = Ee("File");
var ai = Ee("Blob");
var ci = Ee("FileList");
var ui = (n) => zt(n) && fe(n.pipe);
var li = (n) => {
  let e;
  return n && (typeof FormData == "function" && n instanceof FormData || fe(n.append) && ((e = Ht(n)) === "formdata" || e === "object" && fe(n.toString) && n.toString() === "[object FormData]"));
};
var fi = Ee("URLSearchParams");
var hi = (n) => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function wt(n, e, { allOwnKeys: t = false } = {}) {
  if (n === null || typeof n > "u")
    return;
  let r, s;
  if (typeof n != "object" && (n = [n]), Ze(n))
    for (r = 0, s = n.length; r < s; r++)
      e.call(null, n[r], r, n);
  else {
    const i = t ? Object.getOwnPropertyNames(n) : Object.keys(n), o = i.length;
    let c;
    for (r = 0; r < o; r++)
      c = i[r], e.call(null, n[c], c, n);
  }
}
function qr(n, e) {
  e = e.toLowerCase();
  const t = Object.keys(n);
  let r = t.length, s;
  for (; r-- > 0; )
    if (s = t[r], e === s.toLowerCase())
      return s;
  return null;
}
var Vr = /* @__PURE__ */ (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : F)();
var Mr = (n) => !dt(n) && n !== Vr;
function vn() {
  const { caseless: n } = Mr(this) && this || {}, e = {}, t = (r, s) => {
    const i = n && qr(e, s) || s;
    Ut(e[i]) && Ut(r) ? e[i] = vn(e[i], r) : Ut(r) ? e[i] = vn({}, r) : Ze(r) ? e[i] = r.slice() : e[i] = r;
  };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && wt(arguments[r], t);
  return e;
}
var di = (n, e, t, { allOwnKeys: r } = {}) => (wt(e, (s, i) => {
  t && fe(s) ? n[i] = Ur(s, t) : n[i] = s;
}, { allOwnKeys: r }), n);
var pi = (n) => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n);
var yi = (n, e, t, r) => {
  n.prototype = Object.create(e.prototype, r), n.prototype.constructor = n, Object.defineProperty(n, "super", {
    value: e.prototype
  }), t && Object.assign(n.prototype, t);
};
var mi = (n, e, t, r) => {
  let s, i, o;
  const c = {};
  if (e = e || {}, n == null)
    return e;
  do {
    for (s = Object.getOwnPropertyNames(n), i = s.length; i-- > 0; )
      o = s[i], (!r || r(o, n, e)) && !c[o] && (e[o] = n[o], c[o] = true);
    n = t !== false && Pn(n);
  } while (n && (!t || t(n, e)) && n !== Object.prototype);
  return e;
};
var gi = (n, e, t) => {
  n = String(n), (t === void 0 || t > n.length) && (t = n.length), t -= e.length;
  const r = n.indexOf(e, t);
  return r !== -1 && r === t;
};
var vi = (n) => {
  if (!n)
    return null;
  if (Ze(n))
    return n;
  let e = n.length;
  if (!jr(e))
    return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = n[e];
  return t;
};
var wi = /* @__PURE__ */ ((n) => (e) => n && e instanceof n)(typeof Uint8Array < "u" && Pn(Uint8Array));
var bi = (n, e) => {
  const r = (n && n[Symbol.iterator]).call(n);
  let s;
  for (; (s = r.next()) && !s.done; ) {
    const i = s.value;
    e.call(n, i[0], i[1]);
  }
};
var _i = (n, e) => {
  let t;
  const r = [];
  for (; (t = n.exec(e)) !== null; )
    r.push(t);
  return r;
};
var Ei = Ee("HTMLFormElement");
var Si = (n) => n.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, r, s) {
    return r.toUpperCase() + s;
  }
);
var sr = (({ hasOwnProperty: n }) => (e, t) => n.call(e, t))(Object.prototype);
var Ri = Ee("RegExp");
var $r = (n, e) => {
  const t = Object.getOwnPropertyDescriptors(n), r = {};
  wt(t, (s, i) => {
    let o;
    (o = e(s, i, n)) !== false && (r[i] = o || s);
  }), Object.defineProperties(n, r);
};
var Ti = (n) => {
  $r(n, (e, t) => {
    if (fe(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return false;
    const r = n[t];
    if (!!fe(r)) {
      if (e.enumerable = false, "writable" in e) {
        e.writable = false;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
};
var Oi = (n, e) => {
  const t = {}, r = (s) => {
    s.forEach((i) => {
      t[i] = true;
    });
  };
  return Ze(n) ? r(n) : r(String(n).split(e)), t;
};
var xi = () => {
};
var Ai = (n, e) => (n = +n, Number.isFinite(n) ? n : e);
var sn = "abcdefghijklmnopqrstuvwxyz";
var ir = "0123456789";
var Wr = {
  DIGIT: ir,
  ALPHA: sn,
  ALPHA_DIGIT: sn + sn.toUpperCase() + ir
};
var Ci = (n = 16, e = Wr.ALPHA_DIGIT) => {
  let t = "";
  const { length: r } = e;
  for (; n--; )
    t += e[Math.random() * r | 0];
  return t;
};
function Di(n) {
  return !!(n && fe(n.append) && n[Symbol.toStringTag] === "FormData" && n[Symbol.iterator]);
}
var ki = (n) => {
  const e = new Array(10), t = (r, s) => {
    if (zt(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        e[s] = r;
        const i = Ze(r) ? [] : {};
        return wt(r, (o, c) => {
          const l = t(o, s + 1);
          !dt(l) && (i[c] = l);
        }), e[s] = void 0, i;
      }
    }
    return r;
  };
  return t(n, 0);
};
var Ni = Ee("AsyncFunction");
var Li = (n) => n && (zt(n) || fe(n)) && fe(n.then) && fe(n.catch);
var d = {
  isArray: Ze,
  isArrayBuffer: Ir,
  isBuffer: ti,
  isFormData: li,
  isArrayBufferView: ni,
  isString: ri,
  isNumber: jr,
  isBoolean: si,
  isObject: zt,
  isPlainObject: Ut,
  isUndefined: dt,
  isDate: ii,
  isFile: oi,
  isBlob: ai,
  isRegExp: Ri,
  isFunction: fe,
  isStream: ui,
  isURLSearchParams: fi,
  isTypedArray: wi,
  isFileList: ci,
  forEach: wt,
  merge: vn,
  extend: di,
  trim: hi,
  stripBOM: pi,
  inherits: yi,
  toFlatObject: mi,
  kindOf: Ht,
  kindOfTest: Ee,
  endsWith: gi,
  toArray: vi,
  forEachEntry: bi,
  matchAll: _i,
  isHTMLForm: Ei,
  hasOwnProperty: sr,
  hasOwnProp: sr,
  reduceDescriptors: $r,
  freezeMethods: Ti,
  toObjectSet: Oi,
  toCamelCase: Si,
  noop: xi,
  toFiniteNumber: Ai,
  findKey: qr,
  global: Vr,
  isContextDefined: Mr,
  ALPHABET: Wr,
  generateString: Ci,
  isSpecCompliantForm: Di,
  toJSONObject: ki,
  isAsyncFn: Ni,
  isThenable: Li
};
function C(n, e, t, r, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = n, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), r && (this.request = r), s && (this.response = s);
}
d.inherits(C, Error, {
  toJSON: function() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: d.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var Hr = C.prototype;
var Jr = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((n) => {
  Jr[n] = { value: n };
});
Object.defineProperties(C, Jr);
Object.defineProperty(Hr, "isAxiosError", { value: true });
C.from = (n, e, t, r, s, i) => {
  const o = Object.create(Hr);
  return d.toFlatObject(n, o, function(l) {
    return l !== Error.prototype;
  }, (c) => c !== "isAxiosError"), C.call(o, n.message, e, t, r, s), o.cause = n, o.name = n.name, i && Object.assign(o, i), o;
};
var Fi = null;
function wn(n) {
  return d.isPlainObject(n) || d.isArray(n);
}
function zr(n) {
  return d.endsWith(n, "[]") ? n.slice(0, -2) : n;
}
function or(n, e, t) {
  return n ? n.concat(e).map(function(s, i) {
    return s = zr(s), !t && i ? "[" + s + "]" : s;
  }).join(t ? "." : "") : e;
}
function Pi(n) {
  return d.isArray(n) && !n.some(wn);
}
var Bi = d.toFlatObject(d, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function Kt(n, e, t) {
  if (!d.isObject(n))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = d.toFlatObject(t, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function(y, E) {
    return !d.isUndefined(E[y]);
  });
  const r = t.metaTokens, s = t.visitor || f, i = t.dots, o = t.indexes, l = (t.Blob || typeof Blob < "u" && Blob) && d.isSpecCompliantForm(e);
  if (!d.isFunction(s))
    throw new TypeError("visitor must be a function");
  function a(p) {
    if (p === null)
      return "";
    if (d.isDate(p))
      return p.toISOString();
    if (!l && d.isBlob(p))
      throw new C("Blob is not supported. Use a Buffer instead.");
    return d.isArrayBuffer(p) || d.isTypedArray(p) ? l && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p;
  }
  function f(p, y, E) {
    let b = p;
    if (p && !E && typeof p == "object") {
      if (d.endsWith(y, "{}"))
        y = r ? y : y.slice(0, -2), p = JSON.stringify(p);
      else if (d.isArray(p) && Pi(p) || (d.isFileList(p) || d.endsWith(y, "[]")) && (b = d.toArray(p)))
        return y = zr(y), b.forEach(function(O, x) {
          !(d.isUndefined(O) || O === null) && e.append(
            o === true ? or([y], x, i) : o === null ? y : y + "[]",
            a(O)
          );
        }), false;
    }
    return wn(p) ? true : (e.append(or(E, y, i), a(p)), false);
  }
  const h = [], g = Object.assign(Bi, {
    defaultVisitor: f,
    convertValue: a,
    isVisitable: wn
  });
  function v(p, y) {
    if (!d.isUndefined(p)) {
      if (h.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      h.push(p), d.forEach(p, function(b, R) {
        (!(d.isUndefined(b) || b === null) && s.call(
          e,
          b,
          d.isString(R) ? R.trim() : R,
          y,
          g
        )) === true && v(b, y ? y.concat(R) : [R]);
      }), h.pop();
    }
  }
  if (!d.isObject(n))
    throw new TypeError("data must be an object");
  return v(n), e;
}
function ar(n) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function Bn(n, e) {
  this._pairs = [], n && Kt(n, this, e);
}
var Kr = Bn.prototype;
Kr.append = function(e, t) {
  this._pairs.push([e, t]);
};
Kr.toString = function(e) {
  const t = e ? function(r) {
    return e.call(this, r, ar);
  } : ar;
  return this._pairs.map(function(s) {
    return t(s[0]) + "=" + t(s[1]);
  }, "").join("&");
};
function Ui(n) {
  return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function Yr(n, e, t) {
  if (!e)
    return n;
  const r = t && t.encode || Ui, s = t && t.serialize;
  let i;
  if (s ? i = s(e, t) : i = d.isURLSearchParams(e) ? e.toString() : new Bn(e, t).toString(r), i) {
    const o = n.indexOf("#");
    o !== -1 && (n = n.slice(0, o)), n += (n.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return n;
}
var Ii = class {
  constructor() {
    this.handlers = [];
  }
  use(e, t, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: r ? r.synchronous : false,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(e) {
    d.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
};
var cr = Ii;
var Gr = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var ji = typeof URLSearchParams < "u" ? URLSearchParams : Bn;
var qi = typeof FormData < "u" ? FormData : null;
var Vi = typeof Blob < "u" ? Blob : null;
var Mi = {
  isBrowser: true,
  classes: {
    URLSearchParams: ji,
    FormData: qi,
    Blob: Vi
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
var Xr = typeof window < "u" && typeof document < "u";
var $i = ((n) => Xr && ["ReactNative", "NativeScript", "NS"].indexOf(n) < 0)(typeof navigator < "u" && navigator.product);
var Wi = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")();
var Hi = Object.freeze({
  __proto__: null,
  hasBrowserEnv: Xr,
  hasStandardBrowserWebWorkerEnv: Wi,
  hasStandardBrowserEnv: $i
});
var we = {
  ...Hi,
  ...Mi
};
function Ji(n, e) {
  return Kt(n, new we.classes.URLSearchParams(), Object.assign({
    visitor: function(t, r, s, i) {
      return we.isNode && d.isBuffer(t) ? (this.append(r, t.toString("base64")), false) : i.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function zi(n) {
  return d.matchAll(/\w+|\[(\w*)]/g, n).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function Ki(n) {
  const e = {}, t = Object.keys(n);
  let r;
  const s = t.length;
  let i;
  for (r = 0; r < s; r++)
    i = t[r], e[i] = n[i];
  return e;
}
function Qr(n) {
  function e(t, r, s, i) {
    let o = t[i++];
    if (o === "__proto__")
      return true;
    const c = Number.isFinite(+o), l = i >= t.length;
    return o = !o && d.isArray(s) ? s.length : o, l ? (d.hasOwnProp(s, o) ? s[o] = [s[o], r] : s[o] = r, !c) : ((!s[o] || !d.isObject(s[o])) && (s[o] = []), e(t, r, s[o], i) && d.isArray(s[o]) && (s[o] = Ki(s[o])), !c);
  }
  if (d.isFormData(n) && d.isFunction(n.entries)) {
    const t = {};
    return d.forEachEntry(n, (r, s) => {
      e(zi(r), s, t, 0);
    }), t;
  }
  return null;
}
function Yi(n, e, t) {
  if (d.isString(n))
    try {
      return (e || JSON.parse)(n), d.trim(n);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (t || JSON.stringify)(n);
}
var Un = {
  transitional: Gr,
  adapter: ["xhr", "http"],
  transformRequest: [function(e, t) {
    const r = t.getContentType() || "", s = r.indexOf("application/json") > -1, i = d.isObject(e);
    if (i && d.isHTMLForm(e) && (e = new FormData(e)), d.isFormData(e))
      return s ? JSON.stringify(Qr(e)) : e;
    if (d.isArrayBuffer(e) || d.isBuffer(e) || d.isStream(e) || d.isFile(e) || d.isBlob(e))
      return e;
    if (d.isArrayBufferView(e))
      return e.buffer;
    if (d.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e.toString();
    let c;
    if (i) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return Ji(e, this.formSerializer).toString();
      if ((c = d.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return Kt(
          c ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return i || s ? (t.setContentType("application/json", false), Yi(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || Un.transitional, r = t && t.forcedJSONParsing, s = this.responseType === "json";
    if (e && d.isString(e) && (r && !this.responseType || s)) {
      const o = !(t && t.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (c) {
        if (o)
          throw c.name === "SyntaxError" ? C.from(c, C.ERR_BAD_RESPONSE, this, null, this.response) : c;
      }
    }
    return e;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: we.classes.FormData,
    Blob: we.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
d.forEach(["delete", "get", "head", "post", "put", "patch"], (n) => {
  Un.headers[n] = {};
});
var In = Un;
var Gi = d.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var Xi = (n) => {
  const e = {};
  let t, r, s;
  return n && n.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), t = o.substring(0, s).trim().toLowerCase(), r = o.substring(s + 1).trim(), !(!t || e[t] && Gi[t]) && (t === "set-cookie" ? e[t] ? e[t].push(r) : e[t] = [r] : e[t] = e[t] ? e[t] + ", " + r : r);
  }), e;
};
var ur = Symbol("internals");
function at(n) {
  return n && String(n).trim().toLowerCase();
}
function It(n) {
  return n === false || n == null ? n : d.isArray(n) ? n.map(It) : String(n);
}
function Qi(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = t.exec(n); )
    e[r[1]] = r[2];
  return e;
}
var Zi = (n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());
function on(n, e, t, r, s) {
  if (d.isFunction(r))
    return r.call(this, e, t);
  if (s && (e = t), !!d.isString(e)) {
    if (d.isString(r))
      return e.indexOf(r) !== -1;
    if (d.isRegExp(r))
      return r.test(e);
  }
}
function eo(n) {
  return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r);
}
function to(n, e) {
  const t = d.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(n, r + t, {
      value: function(s, i, o) {
        return this[r].call(this, e, s, i, o);
      },
      configurable: true
    });
  });
}
var Yt = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, r) {
    const s = this;
    function i(c, l, a) {
      const f = at(l);
      if (!f)
        throw new Error("header name must be a non-empty string");
      const h = d.findKey(s, f);
      (!h || s[h] === void 0 || a === true || a === void 0 && s[h] !== false) && (s[h || l] = It(c));
    }
    const o = (c, l) => d.forEach(c, (a, f) => i(a, f, l));
    return d.isPlainObject(e) || e instanceof this.constructor ? o(e, t) : d.isString(e) && (e = e.trim()) && !Zi(e) ? o(Xi(e), t) : e != null && i(t, e, r), this;
  }
  get(e, t) {
    if (e = at(e), e) {
      const r = d.findKey(this, e);
      if (r) {
        const s = this[r];
        if (!t)
          return s;
        if (t === true)
          return Qi(s);
        if (d.isFunction(t))
          return t.call(this, s, r);
        if (d.isRegExp(t))
          return t.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = at(e), e) {
      const r = d.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!t || on(this, this[r], r, t)));
    }
    return false;
  }
  delete(e, t) {
    const r = this;
    let s = false;
    function i(o) {
      if (o = at(o), o) {
        const c = d.findKey(r, o);
        c && (!t || on(r, r[c], c, t)) && (delete r[c], s = true);
      }
    }
    return d.isArray(e) ? e.forEach(i) : i(e), s;
  }
  clear(e) {
    const t = Object.keys(this);
    let r = t.length, s = false;
    for (; r--; ) {
      const i = t[r];
      (!e || on(this, this[i], i, e, true)) && (delete this[i], s = true);
    }
    return s;
  }
  normalize(e) {
    const t = this, r = {};
    return d.forEach(this, (s, i) => {
      const o = d.findKey(r, i);
      if (o) {
        t[o] = It(s), delete t[i];
        return;
      }
      const c = e ? eo(i) : String(i).trim();
      c !== i && delete t[i], t[c] = It(s), r[c] = true;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return d.forEach(this, (r, s) => {
      r != null && r !== false && (t[s] = e && d.isArray(r) ? r.join(", ") : r);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const r = new this(e);
    return t.forEach((s) => r.set(s)), r;
  }
  static accessor(e) {
    const r = (this[ur] = this[ur] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function i(o) {
      const c = at(o);
      r[c] || (to(s, o), r[c] = true);
    }
    return d.isArray(e) ? e.forEach(i) : i(e), this;
  }
};
Yt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
d.reduceDescriptors(Yt.prototype, ({ value: n }, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => n,
    set(r) {
      this[t] = r;
    }
  };
});
d.freezeMethods(Yt);
var Ce = Yt;
function an(n, e) {
  const t = this || In, r = e || t, s = Ce.from(r.headers);
  let i = r.data;
  return d.forEach(n, function(c) {
    i = c.call(t, i, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), i;
}
function Zr(n) {
  return !!(n && n.__CANCEL__);
}
function bt(n, e, t) {
  C.call(this, n == null ? "canceled" : n, C.ERR_CANCELED, e, t), this.name = "CanceledError";
}
d.inherits(bt, C, {
  __CANCEL__: true
});
function no(n, e, t) {
  const r = t.config.validateStatus;
  !t.status || !r || r(t.status) ? n(t) : e(new C(
    "Request failed with status code " + t.status,
    [C.ERR_BAD_REQUEST, C.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4],
    t.config,
    t.request,
    t
  ));
}
var ro = we.hasStandardBrowserEnv ? {
  write(n, e, t, r, s, i) {
    const o = [n + "=" + encodeURIComponent(e)];
    d.isNumber(t) && o.push("expires=" + new Date(t).toGMTString()), d.isString(r) && o.push("path=" + r), d.isString(s) && o.push("domain=" + s), i === true && o.push("secure"), document.cookie = o.join("; ");
  },
  read(n) {
    const e = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
    return e ? decodeURIComponent(e[3]) : null;
  },
  remove(n) {
    this.write(n, "", Date.now() - 864e5);
  }
} : {
  write() {
  },
  read() {
    return null;
  },
  remove() {
  }
};
function so(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function io(n, e) {
  return e ? n.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : n;
}
function es(n, e) {
  return n && !so(e) ? io(n, e) : e;
}
var oo = we.hasStandardBrowserEnv ? function() {
  const e = /(msie|trident)/i.test(navigator.userAgent), t = document.createElement("a");
  let r;
  function s(i) {
    let o = i;
    return e && (t.setAttribute("href", o), o = t.href), t.setAttribute("href", o), {
      href: t.href,
      protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
      host: t.host,
      search: t.search ? t.search.replace(/^\?/, "") : "",
      hash: t.hash ? t.hash.replace(/^#/, "") : "",
      hostname: t.hostname,
      port: t.port,
      pathname: t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname
    };
  }
  return r = s(window.location.href), function(o) {
    const c = d.isString(o) ? s(o) : o;
    return c.protocol === r.protocol && c.host === r.host;
  };
}() : /* @__PURE__ */ function() {
  return function() {
    return true;
  };
}();
function ao(n) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
  return e && e[1] || "";
}
function co(n, e) {
  n = n || 10;
  const t = new Array(n), r = new Array(n);
  let s = 0, i = 0, o;
  return e = e !== void 0 ? e : 1e3, function(l) {
    const a = Date.now(), f = r[i];
    o || (o = a), t[s] = l, r[s] = a;
    let h = i, g = 0;
    for (; h !== s; )
      g += t[h++], h = h % n;
    if (s = (s + 1) % n, s === i && (i = (i + 1) % n), a - o < e)
      return;
    const v = f && a - f;
    return v ? Math.round(g * 1e3 / v) : void 0;
  };
}
function lr(n, e) {
  let t = 0;
  const r = co(50, 250);
  return (s) => {
    const i = s.loaded, o = s.lengthComputable ? s.total : void 0, c = i - t, l = r(c), a = i <= o;
    t = i;
    const f = {
      loaded: i,
      total: o,
      progress: o ? i / o : void 0,
      bytes: c,
      rate: l || void 0,
      estimated: l && o && a ? (o - i) / l : void 0,
      event: s
    };
    f[e ? "download" : "upload"] = true, n(f);
  };
}
var uo = typeof XMLHttpRequest < "u";
var lo = uo && function(n) {
  return new Promise(function(t, r) {
    let s = n.data;
    const i = Ce.from(n.headers).normalize();
    let { responseType: o, withXSRFToken: c } = n, l;
    function a() {
      n.cancelToken && n.cancelToken.unsubscribe(l), n.signal && n.signal.removeEventListener("abort", l);
    }
    let f;
    if (d.isFormData(s)) {
      if (we.hasStandardBrowserEnv || we.hasStandardBrowserWebWorkerEnv)
        i.setContentType(false);
      else if ((f = i.getContentType()) !== false) {
        const [y, ...E] = f ? f.split(";").map((b) => b.trim()).filter(Boolean) : [];
        i.setContentType([y || "multipart/form-data", ...E].join("; "));
      }
    }
    let h = new XMLHttpRequest();
    if (n.auth) {
      const y = n.auth.username || "", E = n.auth.password ? unescape(encodeURIComponent(n.auth.password)) : "";
      i.set("Authorization", "Basic " + btoa(y + ":" + E));
    }
    const g = es(n.baseURL, n.url);
    h.open(n.method.toUpperCase(), Yr(g, n.params, n.paramsSerializer), true), h.timeout = n.timeout;
    function v() {
      if (!h)
        return;
      const y = Ce.from(
        "getAllResponseHeaders" in h && h.getAllResponseHeaders()
      ), b = {
        data: !o || o === "text" || o === "json" ? h.responseText : h.response,
        status: h.status,
        statusText: h.statusText,
        headers: y,
        config: n,
        request: h
      };
      no(function(O) {
        t(O), a();
      }, function(O) {
        r(O), a();
      }, b), h = null;
    }
    if ("onloadend" in h ? h.onloadend = v : h.onreadystatechange = function() {
      !h || h.readyState !== 4 || h.status === 0 && !(h.responseURL && h.responseURL.indexOf("file:") === 0) || setTimeout(v);
    }, h.onabort = function() {
      !h || (r(new C("Request aborted", C.ECONNABORTED, n, h)), h = null);
    }, h.onerror = function() {
      r(new C("Network Error", C.ERR_NETWORK, n, h)), h = null;
    }, h.ontimeout = function() {
      let E = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
      const b = n.transitional || Gr;
      n.timeoutErrorMessage && (E = n.timeoutErrorMessage), r(new C(
        E,
        b.clarifyTimeoutError ? C.ETIMEDOUT : C.ECONNABORTED,
        n,
        h
      )), h = null;
    }, we.hasStandardBrowserEnv && (c && d.isFunction(c) && (c = c(n)), c || c !== false && oo(g))) {
      const y = n.xsrfHeaderName && n.xsrfCookieName && ro.read(n.xsrfCookieName);
      y && i.set(n.xsrfHeaderName, y);
    }
    s === void 0 && i.setContentType(null), "setRequestHeader" in h && d.forEach(i.toJSON(), function(E, b) {
      h.setRequestHeader(b, E);
    }), d.isUndefined(n.withCredentials) || (h.withCredentials = !!n.withCredentials), o && o !== "json" && (h.responseType = n.responseType), typeof n.onDownloadProgress == "function" && h.addEventListener("progress", lr(n.onDownloadProgress, true)), typeof n.onUploadProgress == "function" && h.upload && h.upload.addEventListener("progress", lr(n.onUploadProgress)), (n.cancelToken || n.signal) && (l = (y) => {
      !h || (r(!y || y.type ? new bt(null, n, h) : y), h.abort(), h = null);
    }, n.cancelToken && n.cancelToken.subscribe(l), n.signal && (n.signal.aborted ? l() : n.signal.addEventListener("abort", l)));
    const p = ao(g);
    if (p && we.protocols.indexOf(p) === -1) {
      r(new C("Unsupported protocol " + p + ":", C.ERR_BAD_REQUEST, n));
      return;
    }
    h.send(s || null);
  });
};
var bn = {
  http: Fi,
  xhr: lo
};
d.forEach(bn, (n, e) => {
  if (n) {
    try {
      Object.defineProperty(n, "name", { value: e });
    } catch {
    }
    Object.defineProperty(n, "adapterName", { value: e });
  }
});
var fr = (n) => `- ${n}`;
var fo = (n) => d.isFunction(n) || n === null || n === false;
var ts = {
  getAdapter: (n) => {
    n = d.isArray(n) ? n : [n];
    const { length: e } = n;
    let t, r;
    const s = {};
    for (let i = 0; i < e; i++) {
      t = n[i];
      let o;
      if (r = t, !fo(t) && (r = bn[(o = String(t)).toLowerCase()], r === void 0))
        throw new C(`Unknown adapter '${o}'`);
      if (r)
        break;
      s[o || "#" + i] = r;
    }
    if (!r) {
      const i = Object.entries(s).map(
        ([c, l]) => `adapter ${c} ` + (l === false ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? i.length > 1 ? `since :
` + i.map(fr).join(`
`) : " " + fr(i[0]) : "as no adapter specified";
      throw new C(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: bn
};
function cn(n) {
  if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted)
    throw new bt(null, n);
}
function hr(n) {
  return cn(n), n.headers = Ce.from(n.headers), n.data = an.call(
    n,
    n.transformRequest
  ), ["post", "put", "patch"].indexOf(n.method) !== -1 && n.headers.setContentType("application/x-www-form-urlencoded", false), ts.getAdapter(n.adapter || In.adapter)(n).then(function(r) {
    return cn(n), r.data = an.call(
      n,
      n.transformResponse,
      r
    ), r.headers = Ce.from(r.headers), r;
  }, function(r) {
    return Zr(r) || (cn(n), r && r.response && (r.response.data = an.call(
      n,
      n.transformResponse,
      r.response
    ), r.response.headers = Ce.from(r.response.headers))), Promise.reject(r);
  });
}
var dr = (n) => n instanceof Ce ? n.toJSON() : n;
function Xe(n, e) {
  e = e || {};
  const t = {};
  function r(a, f, h) {
    return d.isPlainObject(a) && d.isPlainObject(f) ? d.merge.call({ caseless: h }, a, f) : d.isPlainObject(f) ? d.merge({}, f) : d.isArray(f) ? f.slice() : f;
  }
  function s(a, f, h) {
    if (d.isUndefined(f)) {
      if (!d.isUndefined(a))
        return r(void 0, a, h);
    } else
      return r(a, f, h);
  }
  function i(a, f) {
    if (!d.isUndefined(f))
      return r(void 0, f);
  }
  function o(a, f) {
    if (d.isUndefined(f)) {
      if (!d.isUndefined(a))
        return r(void 0, a);
    } else
      return r(void 0, f);
  }
  function c(a, f, h) {
    if (h in e)
      return r(a, f);
    if (h in n)
      return r(void 0, a);
  }
  const l = {
    url: i,
    method: i,
    data: i,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: c,
    headers: (a, f) => s(dr(a), dr(f), true)
  };
  return d.forEach(Object.keys(Object.assign({}, n, e)), function(f) {
    const h = l[f] || s, g = h(n[f], e[f], f);
    d.isUndefined(g) && h !== c || (t[f] = g);
  }), t;
}
var ns = "1.6.7";
var jn = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((n, e) => {
  jn[n] = function(r) {
    return typeof r === n || "a" + (e < 1 ? "n " : " ") + n;
  };
});
var pr = {};
jn.transitional = function(e, t, r) {
  function s(i, o) {
    return "[Axios v" + ns + "] Transitional option '" + i + "'" + o + (r ? ". " + r : "");
  }
  return (i, o, c) => {
    if (e === false)
      throw new C(
        s(o, " has been removed" + (t ? " in " + t : "")),
        C.ERR_DEPRECATED
      );
    return t && !pr[o] && (pr[o] = true, console.warn(
      s(
        o,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(i, o, c) : true;
  };
};
function ho(n, e, t) {
  if (typeof n != "object")
    throw new C("options must be an object", C.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(n);
  let s = r.length;
  for (; s-- > 0; ) {
    const i = r[s], o = e[i];
    if (o) {
      const c = n[i], l = c === void 0 || o(c, i, n);
      if (l !== true)
        throw new C("option " + i + " must be " + l, C.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== true)
      throw new C("Unknown option " + i, C.ERR_BAD_OPTION);
  }
}
var _n = {
  assertOptions: ho,
  validators: jn
};
var ke = _n.validators;
var Wt = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new cr(),
      response: new cr()
    };
  }
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (r) {
      if (r instanceof Error) {
        let s;
        Error.captureStackTrace ? Error.captureStackTrace(s = {}) : s = new Error();
        const i = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        r.stack ? i && !String(r.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + i) : r.stack = i;
      }
      throw r;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Xe(this.defaults, t);
    const { transitional: r, paramsSerializer: s, headers: i } = t;
    r !== void 0 && _n.assertOptions(r, {
      silentJSONParsing: ke.transitional(ke.boolean),
      forcedJSONParsing: ke.transitional(ke.boolean),
      clarifyTimeoutError: ke.transitional(ke.boolean)
    }, false), s != null && (d.isFunction(s) ? t.paramsSerializer = {
      serialize: s
    } : _n.assertOptions(s, {
      encode: ke.function,
      serialize: ke.function
    }, true)), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let o = i && d.merge(
      i.common,
      i[t.method]
    );
    i && d.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (p) => {
        delete i[p];
      }
    ), t.headers = Ce.concat(o, i);
    const c = [];
    let l = true;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(t) === false || (l = l && y.synchronous, c.unshift(y.fulfilled, y.rejected));
    });
    const a = [];
    this.interceptors.response.forEach(function(y) {
      a.push(y.fulfilled, y.rejected);
    });
    let f, h = 0, g;
    if (!l) {
      const p = [hr.bind(this), void 0];
      for (p.unshift.apply(p, c), p.push.apply(p, a), g = p.length, f = Promise.resolve(t); h < g; )
        f = f.then(p[h++], p[h++]);
      return f;
    }
    g = c.length;
    let v = t;
    for (h = 0; h < g; ) {
      const p = c[h++], y = c[h++];
      try {
        v = p(v);
      } catch (E) {
        y.call(this, E);
        break;
      }
    }
    try {
      f = hr.call(this, v);
    } catch (p) {
      return Promise.reject(p);
    }
    for (h = 0, g = a.length; h < g; )
      f = f.then(a[h++], a[h++]);
    return f;
  }
  getUri(e) {
    e = Xe(this.defaults, e);
    const t = es(e.baseURL, e.url);
    return Yr(t, e.params, e.paramsSerializer);
  }
};
d.forEach(["delete", "get", "head", "options"], function(e) {
  Wt.prototype[e] = function(t, r) {
    return this.request(Xe(r || {}, {
      method: e,
      url: t,
      data: (r || {}).data
    }));
  };
});
d.forEach(["post", "put", "patch"], function(e) {
  function t(r) {
    return function(i, o, c) {
      return this.request(Xe(c || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: i,
        data: o
      }));
    };
  }
  Wt.prototype[e] = t(), Wt.prototype[e + "Form"] = t(true);
});
var jt = Wt;
var qn = class _qn {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(i) {
      t = i;
    });
    const r = this;
    this.promise.then((s) => {
      if (!r._listeners)
        return;
      let i = r._listeners.length;
      for (; i-- > 0; )
        r._listeners[i](s);
      r._listeners = null;
    }), this.promise.then = (s) => {
      let i;
      const o = new Promise((c) => {
        r.subscribe(c), i = c;
      }).then(s);
      return o.cancel = function() {
        r.unsubscribe(i);
      }, o;
    }, e(function(i, o, c) {
      r.reason || (r.reason = new bt(i, o, c), t(r.reason));
    });
  }
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  static source() {
    let e;
    return {
      token: new _qn(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
var po = qn;
function yo(n) {
  return function(t) {
    return n.apply(null, t);
  };
}
function mo(n) {
  return d.isObject(n) && n.isAxiosError === true;
}
var En = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(En).forEach(([n, e]) => {
  En[e] = n;
});
var go = En;
function rs(n) {
  const e = new jt(n), t = Ur(jt.prototype.request, e);
  return d.extend(t, jt.prototype, e, { allOwnKeys: true }), d.extend(t, e, null, { allOwnKeys: true }), t.create = function(s) {
    return rs(Xe(n, s));
  }, t;
}
var G = rs(In);
G.Axios = jt;
G.CanceledError = bt;
G.CancelToken = po;
G.isCancel = Zr;
G.VERSION = ns;
G.toFormData = Kt;
G.AxiosError = C;
G.Cancel = G.CanceledError;
G.all = function(e) {
  return Promise.all(e);
};
G.spread = yo;
G.isAxiosError = mo;
G.mergeConfig = Xe;
G.AxiosHeaders = Ce;
G.formToJSON = (n) => Qr(d.isHTMLForm(n) ? new FormData(n) : n);
G.getAdapter = ts.getAdapter;
G.HttpStatusCode = go;
G.default = G;
var vo = G;
Object.defineProperty(Ge, "__esModule", { value: true });
Ge.getRequestHeaders = Ge.getAxiosClient = void 0;
var wo = vo;
function bo(n, e, t, r) {
  return wo.default.create({
    baseURL: n,
    headers: ss(e, r, t),
    withCredentials: true
  });
}
Ge.getAxiosClient = bo;
function ss(n, e, t) {
  n === void 0 && (n = false);
  var r = {
    Accept: "application/json",
    "Content-Type": "application/json; charset=utf-8"
  };
  return n && e && t && (r.Authorization = "".concat(e, " ").concat(t())), typeof window < "u" && typeof document < "u" && (window.location && (r["X-Frappe-Site-Name"] = window.location.hostname), window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && (r["X-Frappe-CSRF-Token"] = window.csrf_token)), r;
}
Ge.getRequestHeaders = ss;
var yr;
function _o() {
  if (yr)
    return ot;
  yr = 1, Object.defineProperty(ot, "__esModule", { value: true }), ot.FrappeApp = void 0;
  var n = is(), e = mt, t = gt, r = vt, s = Ge, i = function() {
    function o(c, l, a) {
      var f, h;
      this.url = c, this.name = a != null ? a : "FrappeApp", this.useToken = (f = l == null ? void 0 : l.useToken) !== null && f !== void 0 ? f : false, this.token = l == null ? void 0 : l.token, this.tokenType = (h = l == null ? void 0 : l.type) !== null && h !== void 0 ? h : "Bearer", this.axios = (0, s.getAxiosClient)(this.url, this.useToken, this.token, this.tokenType);
    }
    return o.prototype.auth = function() {
      return new n.FrappeAuth(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.db = function() {
      return new t.FrappeDB(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.file = function() {
      return new r.FrappeFileUpload(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.call = function() {
      return new e.FrappeCall(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o;
  }();
  return ot.FrappeApp = i, ot;
}
var Gt = {};
var ge = F && F.__assign || function() {
  return ge = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, ge.apply(this, arguments);
};
var Ct = F && F.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(f) {
      try {
        a(r.next(f));
      } catch (h) {
        o(h);
      }
    }
    function l(f) {
      try {
        a(r.throw(f));
      } catch (h) {
        o(h);
      }
    }
    function a(f) {
      f.done ? i(f.value) : s(f.value).then(c, l);
    }
    a((r = r.apply(n, e || [])).next());
  });
};
var Dt = F && F.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(f) {
      return l([a, f]);
    };
  }
  function l(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, a[0] && (t = 0)), t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: false };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: true };
  }
};
Object.defineProperty(Gt, "__esModule", { value: true });
Gt.FrappeAuth = void 0;
var Eo = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : false, this.token = s, this.tokenType = i;
  }
  return n.prototype.loginWithUsernamePassword = function(e) {
    return Ct(this, void 0, void 0, function() {
      return Dt(this, function(t) {
        return [2, this.axios.post("/api/method/login", {
          usr: e.username,
          pwd: e.password,
          otp: e.otp,
          tmp_id: e.tmp_id,
          device: e.device
        }).then(function(r) {
          return r.data;
        }).catch(function(r) {
          var s, i;
          throw ge(ge({}, r.response.data), { httpStatus: r.response.status, httpStatusText: r.response.statusText, message: (s = r.response.data.message) !== null && s !== void 0 ? s : "There was an error while logging in", exception: (i = r.response.data.exception) !== null && i !== void 0 ? i : "" });
        })];
      });
    });
  }, n.prototype.getLoggedInUser = function() {
    return Ct(this, void 0, void 0, function() {
      return Dt(this, function(e) {
        return [2, this.axios.get("/api/method/frappe.auth.get_logged_user").then(function(t) {
          return t.data.message;
        }).catch(function(t) {
          var r;
          throw ge(ge({}, t.response.data), { httpStatus: t.response.status, httpStatusText: t.response.statusText, message: "There was an error while fetching the logged in user", exception: (r = t.response.data.exception) !== null && r !== void 0 ? r : "" });
        })];
      });
    });
  }, n.prototype.logout = function() {
    return Ct(this, void 0, void 0, function() {
      return Dt(this, function(e) {
        return [2, this.axios.post("/api/method/logout", {}).then(function() {
        }).catch(function(t) {
          var r, s;
          throw ge(ge({}, t.response.data), { httpStatus: t.response.status, httpStatusText: t.response.statusText, message: (r = t.response.data.message) !== null && r !== void 0 ? r : "There was an error while logging out", exception: (s = t.response.data.exception) !== null && s !== void 0 ? s : "" });
        })];
      });
    });
  }, n.prototype.forgetPassword = function(e) {
    return Ct(this, void 0, void 0, function() {
      return Dt(this, function(t) {
        return [2, this.axios.post("/", {
          cmd: "frappe.core.doctype.user.user.reset_password",
          user: e
        }).then(function() {
        }).catch(function(r) {
          var s, i;
          throw ge(ge({}, r.response.data), { httpStatus: r.response.status, httpStatusText: r.response.statusText, message: (s = r.response.data.message) !== null && s !== void 0 ? s : "There was an error sending password reset email.", exception: (i = r.response.data.exception) !== null && i !== void 0 ? i : "" });
        })];
      });
    });
  }, n;
}();
Gt.FrappeAuth = Eo;
var mr;
function is() {
  return mr || (mr = 1, function(n) {
    var e = F && F.__createBinding || (Object.create ? function(r, s, i, o) {
      o === void 0 && (o = i);
      var c = Object.getOwnPropertyDescriptor(s, i);
      (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: true, get: function() {
        return s[i];
      } }), Object.defineProperty(r, o, c);
    } : function(r, s, i, o) {
      o === void 0 && (o = i), r[o] = s[i];
    }), t = F && F.__exportStar || function(r, s) {
      for (var i in r)
        i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i);
    };
    Object.defineProperty(n, "__esModule", { value: true }), t(_o(), n), t(Gt, n), t(gt, n), t(vt, n), t(mt, n);
  }(rn)), rn;
}
var So = is();
var os = { exports: {} };
var ln = {};
var vr;
function To() {
  return vr || (vr = 1, function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var n = import_react.default, e = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function t(O) {
      {
        for (var x = arguments.length, L = new Array(x > 1 ? x - 1 : 0), k = 1; k < x; k++)
          L[k - 1] = arguments[k];
        r("error", O, L);
      }
    }
    function r(O, x, L) {
      {
        var k = e.ReactDebugCurrentFrame, re = k.getStackAddendum();
        re !== "" && (x += "%s", L = L.concat([re]));
        var P = L.map(function(W) {
          return String(W);
        });
        P.unshift("Warning: " + x), Function.prototype.apply.call(console[O], console, P);
      }
    }
    function s(O, x) {
      return O === x && (O !== 0 || 1 / O === 1 / x) || O !== O && x !== x;
    }
    var i = typeof Object.is == "function" ? Object.is : s, o = n.useState, c = n.useEffect, l = n.useLayoutEffect, a = n.useDebugValue, f = false, h = false;
    function g(O, x, L) {
      f || n.startTransition !== void 0 && (f = true, t("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var k = x();
      if (!h) {
        var re = x();
        i(k, re) || (t("The result of getSnapshot should be cached to avoid an infinite loop"), h = true);
      }
      var P = o({
        inst: {
          value: k,
          getSnapshot: x
        }
      }), W = P[0].inst, Q = P[1];
      return l(function() {
        W.value = k, W.getSnapshot = x, v(W) && Q({
          inst: W
        });
      }, [O, k, x]), c(function() {
        v(W) && Q({
          inst: W
        });
        var pe = function() {
          v(W) && Q({
            inst: W
          });
        };
        return O(pe);
      }, [O]), a(k), k;
    }
    function v(O) {
      var x = O.getSnapshot, L = O.value;
      try {
        var k = x();
        return !i(L, k);
      } catch {
        return true;
      }
    }
    function p(O, x, L) {
      return x();
    }
    var y = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", E = !y, b = E ? p : g, R = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : b;
    ln.useSyncExternalStore = R, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), ln;
}
(function(n) {
  false ? n.exports = Ro() : n.exports = To();
})(os);
var Le = () => {
};
var oe = Le();
var fn = Object;
var D = (n) => n === oe;
var ve = (n) => typeof n == "function";
var Fe = (n, e) => ({
  ...n,
  ...e
});
var Oo = (n) => ve(n.then);
var kt = /* @__PURE__ */ new WeakMap();
var xo = 0;
var pt = (n) => {
  const e = typeof n, t = n && n.constructor, r = t == Date;
  let s, i;
  if (fn(n) === n && !r && t != RegExp) {
    if (s = kt.get(n), s)
      return s;
    if (s = ++xo + "~", kt.set(n, s), t == Array) {
      for (s = "@", i = 0; i < n.length; i++)
        s += pt(n[i]) + ",";
      kt.set(n, s);
    }
    if (t == fn) {
      s = "#";
      const o = fn.keys(n).sort();
      for (; !D(i = o.pop()); )
        D(n[i]) || (s += i + ":" + pt(n[i]) + ",");
      kt.set(n, s);
    }
  } else
    s = r ? n.toJSON() : e == "symbol" ? n.toString() : e == "string" ? JSON.stringify(n) : "" + n;
  return s;
};
var Ae = /* @__PURE__ */ new WeakMap();
var hn = {};
var Nt = {};
var Vn = "undefined";
var Xt = typeof window != Vn;
var Sn = typeof document != Vn;
var Ao = () => Xt && typeof window.requestAnimationFrame != Vn;
var as = (n, e) => {
  const t = Ae.get(n);
  return [
    () => !D(e) && n.get(e) || hn,
    (r) => {
      if (!D(e)) {
        const s = n.get(e);
        e in Nt || (Nt[e] = s), t[5](e, Fe(s, r), s || hn);
      }
    },
    t[6],
    () => !D(e) && e in Nt ? Nt[e] : !D(e) && n.get(e) || hn
  ];
};
var Rn = true;
var Co = () => Rn;
var [Tn, On] = Xt && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  Le,
  Le
];
var Do = () => {
  const n = Sn && document.visibilityState;
  return D(n) || n !== "hidden";
};
var ko = (n) => (Sn && document.addEventListener("visibilitychange", n), Tn("focus", n), () => {
  Sn && document.removeEventListener("visibilitychange", n), On("focus", n);
});
var No = (n) => {
  const e = () => {
    Rn = true, n();
  }, t = () => {
    Rn = false;
  };
  return Tn("online", e), Tn("offline", t), () => {
    On("online", e), On("offline", t);
  };
};
var Lo = {
  isOnline: Co,
  isVisible: Do
};
var Fo = {
  initFocus: ko,
  initReconnect: No
};
var wr = !import_react.default.useId;
var yt = !Xt || "Deno" in window;
var Po = (n) => Ao() ? window.requestAnimationFrame(n) : setTimeout(n, 1);
var dn = yt ? import_react.useEffect : import_react.useLayoutEffect;
var pn = typeof navigator < "u" && navigator.connection;
var br = !yt && pn && ([
  "slow-2g",
  "2g"
].includes(pn.effectiveType) || pn.saveData);
var Mn = (n) => {
  if (ve(n))
    try {
      n = n();
    } catch {
      n = "";
    }
  const e = n;
  return n = typeof n == "string" ? n : (Array.isArray(n) ? n.length : n) ? pt(n) : "", [
    n,
    e
  ];
};
var Bo = 0;
var xn = () => ++Bo;
var cs = 0;
var us = 1;
var ls = 2;
var Uo = 3;
var ct = {
  __proto__: null,
  ERROR_REVALIDATE_EVENT: Uo,
  FOCUS_EVENT: cs,
  MUTATE_EVENT: ls,
  RECONNECT_EVENT: us
};
async function fs(...n) {
  const [e, t, r, s] = n, i = Fe({
    populateCache: true,
    throwOnError: true
  }, typeof s == "boolean" ? {
    revalidate: s
  } : s || {});
  let o = i.populateCache;
  const c = i.rollbackOnError;
  let l = i.optimisticData;
  const a = (g) => typeof c == "function" ? c(g) : c !== false, f = i.throwOnError;
  if (ve(t)) {
    const g = t, v = [], p = e.keys();
    for (const y of p)
      !/^\$(inf|sub)\$/.test(y) && g(e.get(y)._k) && v.push(y);
    return Promise.all(v.map(h));
  }
  return h(t);
  async function h(g) {
    const [v] = Mn(g);
    if (!v)
      return;
    const [p, y] = as(e, v), [E, b, R, O] = Ae.get(e), x = () => {
      const M = E[v];
      return (ve(i.revalidate) ? i.revalidate(p().data, g) : i.revalidate !== false) && (delete R[v], delete O[v], M && M[0]) ? M[0](ls).then(() => p().data) : p().data;
    };
    if (n.length < 3)
      return x();
    let L = r, k;
    const re = xn();
    b[v] = [
      re,
      0
    ];
    const P = !D(l), W = p(), Q = W.data, pe = W._c, ye = D(pe) ? Q : pe;
    if (P && (l = ve(l) ? l(ye, Q) : l, y({
      data: l,
      _c: ye
    })), ve(L))
      try {
        L = L(ye);
      } catch (M) {
        k = M;
      }
    if (L && Oo(L))
      if (L = await L.catch((M) => {
        k = M;
      }), re !== b[v][0]) {
        if (k)
          throw k;
        return L;
      } else
        k && P && a(k) && (o = true, y({
          data: ye,
          _c: oe
        }));
    if (o && !k)
      if (ve(o)) {
        const M = o(L, ye);
        y({
          data: M,
          error: oe,
          _c: oe
        });
      } else
        y({
          data: L,
          error: oe,
          _c: oe
        });
    if (b[v][1] = xn(), Promise.resolve(x()).then(() => {
      y({
        _c: oe
      });
    }), k) {
      if (f)
        throw k;
      return;
    }
    return L;
  }
}
var _r = (n, e) => {
  for (const t in n)
    n[t][0] && n[t][0](e);
};
var Io = (n, e) => {
  if (!Ae.has(n)) {
    const t = Fe(Fo, e), r = {}, s = fs.bind(oe, n);
    let i = Le;
    const o = {}, c = (f, h) => {
      const g = o[f] || [];
      return o[f] = g, g.push(h), () => g.splice(g.indexOf(h), 1);
    }, l = (f, h, g) => {
      n.set(f, h);
      const v = o[f];
      if (v)
        for (const p of v)
          p(h, g);
    }, a = () => {
      if (!Ae.has(n) && (Ae.set(n, [
        r,
        {},
        {},
        {},
        s,
        l,
        c
      ]), !yt)) {
        const f = t.initFocus(setTimeout.bind(oe, _r.bind(oe, r, cs))), h = t.initReconnect(setTimeout.bind(oe, _r.bind(oe, r, us)));
        i = () => {
          f && f(), h && h(), Ae.delete(n);
        };
      }
    };
    return a(), [
      n,
      s,
      a,
      i
    ];
  }
  return [
    n,
    Ae.get(n)[4]
  ];
};
var jo = (n, e, t, r, s) => {
  const i = t.errorRetryCount, o = s.retryCount, c = ~~((Math.random() + 0.5) * (1 << (o < 8 ? o : 8))) * t.errorRetryInterval;
  !D(i) && o > i || setTimeout(r, c, s);
};
var qo = (n, e) => pt(n) == pt(e);
var [hs, Vo] = Io(/* @__PURE__ */ new Map());
var Mo = Fe(
  {
    onLoadingSlow: Le,
    onSuccess: Le,
    onError: Le,
    onErrorRetry: jo,
    onDiscarded: Le,
    revalidateOnFocus: true,
    revalidateOnReconnect: true,
    revalidateIfStale: true,
    shouldRetryOnError: true,
    errorRetryInterval: br ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: br ? 5e3 : 3e3,
    compare: qo,
    isPaused: () => false,
    cache: hs,
    mutate: Vo,
    fallback: {}
  },
  Lo
);
var $o = (n, e) => {
  const t = Fe(n, e);
  if (e) {
    const { use: r, fallback: s } = n, { use: i, fallback: o } = e;
    r && i && (t.use = r.concat(i)), s && o && (t.fallback = Fe(s, o));
  }
  return t;
};
var Wo = (0, import_react.createContext)({});
var Ho = "$inf$";
var ds = Xt && window.__SWR_DEVTOOLS_USE__;
var Jo = ds ? window.__SWR_DEVTOOLS_USE__ : [];
var zo = () => {
  ds && (window.__SWR_DEVTOOLS_REACT__ = import_react.default);
};
var Ko = (n) => ve(n[1]) ? [
  n[0],
  n[1],
  n[2] || {}
] : [
  n[0],
  null,
  (n[1] === null ? n[2] : n[1]) || {}
];
var Yo = () => Fe(Mo, (0, import_react.useContext)(Wo));
var Go = (n) => (e, t, r) => n(e, t && ((...i) => {
  const [o] = Mn(e), [, , , c] = Ae.get(hs);
  if (o.startsWith(Ho))
    return t(...i);
  const l = c[o];
  return D(l) ? t(...i) : (delete c[o], l);
}), r);
var Xo = Jo.concat(Go);
var Qo = (n) => function(...t) {
  const r = Yo(), [s, i, o] = Ko(t), c = $o(r, o);
  let l = n;
  const { use: a } = c, f = (a || []).concat(Xo);
  for (let h = f.length; h--; )
    l = f[h](l);
  return l(s, i || c.fetcher || null, c);
};
var Zo = (n, e, t) => {
  const r = e[n] || (e[n] = []);
  return r.push(t), () => {
    const s = r.indexOf(t);
    s >= 0 && (r[s] = r[r.length - 1], r.pop());
  };
};
zo();
var Er = import_react.default.use || ((n) => {
  if (n.status === "pending")
    throw n;
  if (n.status === "fulfilled")
    return n.value;
  throw n.status === "rejected" ? n.reason : (n.status = "pending", n.then((e) => {
    n.status = "fulfilled", n.value = e;
  }, (e) => {
    n.status = "rejected", n.reason = e;
  }), n);
});
var yn = {
  dedupe: true
};
var ea = (n, e, t) => {
  const { cache: r, compare: s, suspense: i, fallbackData: o, revalidateOnMount: c, revalidateIfStale: l, refreshInterval: a, refreshWhenHidden: f, refreshWhenOffline: h, keepPreviousData: g } = t, [v, p, y, E] = Ae.get(r), [b, R] = Mn(n), O = (0, import_react.useRef)(false), x = (0, import_react.useRef)(false), L = (0, import_react.useRef)(b), k = (0, import_react.useRef)(e), re = (0, import_react.useRef)(t), P = () => re.current, W = () => P().isVisible() && P().isOnline(), [Q, pe, ye, M] = as(r, b), se = (0, import_react.useRef)({}).current, Pe = D(o) ? t.fallback[b] : o, tt = (B, I) => {
    for (const X in se) {
      const q = X;
      if (q === "data") {
        if (!s(B[q], I[q]) && (!D(B[q]) || !s(Me, I[q])))
          return false;
      } else if (I[q] !== B[q])
        return false;
    }
    return true;
  }, nt = (0, import_react.useMemo)(() => {
    const B = (() => !b || !e ? false : D(c) ? P().isPaused() || i ? false : D(l) ? true : l : c)(), I = (J) => {
      const he = Fe(J);
      return delete he._k, B ? {
        isValidating: true,
        isLoading: true,
        ...he
      } : he;
    }, X = Q(), q = M(), te = I(X), Oe = X === q ? te : I(q);
    let H = te;
    return [
      () => {
        const J = I(Q());
        return tt(J, H) ? (H.data = J.data, H.isLoading = J.isLoading, H.isValidating = J.isValidating, H.error = J.error, H) : (H = J, J);
      },
      () => Oe
    ];
  }, [
    r,
    b
  ]), Se = os.exports.useSyncExternalStore((0, import_react.useCallback)(
    (B) => ye(b, (I, X) => {
      tt(X, I) || B();
    }),
    [
      r,
      b
    ]
  ), nt[0], nt[1]), rt = !O.current, Et = v[b] && v[b].length > 0, Re = Se.data, Te = D(Re) ? Pe : Re, Be = Se.error, St = (0, import_react.useRef)(Te), Me = g ? D(Re) ? St.current : Re : Te, $e = (() => Et && !D(Be) ? false : rt && !D(c) ? c : P().isPaused() ? false : i ? D(Te) ? false : l : D(Te) || l)(), We = !!(b && e && rt && $e), He = D(Se.isValidating) ? We : Se.isValidating, st = D(Se.isLoading) ? We : Se.isLoading, me = (0, import_react.useCallback)(
    async (B) => {
      const I = k.current;
      if (!b || !I || x.current || P().isPaused())
        return false;
      let X, q, te = true;
      const Oe = B || {}, H = !y[b] || !Oe.dedupe, J = () => wr ? !x.current && b === L.current && O.current : b === L.current, he = {
        isValidating: false,
        isLoading: false
      }, Tt = () => {
        pe(he);
      }, Je = () => {
        const ie = y[b];
        ie && ie[1] === q && delete y[b];
      }, Ot = {
        isValidating: true
      };
      D(Q().data) && (Ot.isLoading = true);
      try {
        if (H && (pe(Ot), t.loadingTimeout && D(Q().data) && setTimeout(() => {
          te && J() && P().onLoadingSlow(b, t);
        }, t.loadingTimeout), y[b] = [
          I(R),
          xn()
        ]), [X, q] = y[b], X = await X, H && setTimeout(Je, t.dedupingInterval), !y[b] || y[b][1] !== q)
          return H && J() && P().onDiscarded(b), false;
        he.error = oe;
        const ie = p[b];
        if (!D(ie) && (q <= ie[0] || q <= ie[1] || ie[1] === 0))
          return Tt(), H && J() && P().onDiscarded(b), false;
        const ae = Q().data;
        he.data = s(ae, X) ? ae : X, H && J() && P().onSuccess(X, b, t);
      } catch (ie) {
        Je();
        const ae = P(), { shouldRetryOnError: ze } = ae;
        ae.isPaused() || (he.error = ie, H && J() && (ae.onError(ie, b, ae), (ze === true || ve(ze) && ze(ie)) && (!P().revalidateOnFocus || !P().revalidateOnReconnect || W()) && ae.onErrorRetry(ie, b, ae, (Ue) => {
          const it = v[b];
          it && it[0] && it[0](ct.ERROR_REVALIDATE_EVENT, Ue);
        }, {
          retryCount: (Oe.retryCount || 0) + 1,
          dedupe: true
        })));
      }
      return te = false, Tt(), true;
    },
    [
      b,
      r
    ]
  ), Rt = (0, import_react.useCallback)(
    (...B) => fs(r, L.current, ...B),
    []
  );
  if (dn(() => {
    k.current = e, re.current = t, D(Re) || (St.current = Re);
  }), dn(() => {
    if (!b)
      return;
    const B = me.bind(oe, yn);
    let I = 0;
    const q = Zo(b, v, (te, Oe = {}) => {
      if (te == ct.FOCUS_EVENT) {
        const H = Date.now();
        P().revalidateOnFocus && H > I && W() && (I = H + P().focusThrottleInterval, B());
      } else if (te == ct.RECONNECT_EVENT)
        P().revalidateOnReconnect && W() && B();
      else {
        if (te == ct.MUTATE_EVENT)
          return me();
        if (te == ct.ERROR_REVALIDATE_EVENT)
          return me(Oe);
      }
    });
    return x.current = false, L.current = b, O.current = true, pe({
      _k: R
    }), $e && (D(Te) || yt ? B() : Po(B)), () => {
      x.current = true, q();
    };
  }, [
    b
  ]), dn(() => {
    let B;
    function I() {
      const q = ve(a) ? a(Q().data) : a;
      q && B !== -1 && (B = setTimeout(X, q));
    }
    function X() {
      !Q().error && (f || P().isVisible()) && (h || P().isOnline()) ? me(yn).then(I) : I();
    }
    return I(), () => {
      B && (clearTimeout(B), B = -1);
    };
  }, [
    a,
    f,
    h,
    b
  ]), (0, import_react.useDebugValue)(Me), i && D(Te) && b) {
    if (!wr && yt)
      throw new Error("Fallback data is required when using suspense in SSR.");
    k.current = e, re.current = t, x.current = false;
    const B = E[b];
    if (!D(B)) {
      const I = Rt(B);
      Er(I);
    }
    if (D(Be)) {
      const I = me(yn);
      D(Me) || (I.status = "fulfilled", I.value = true), Er(I);
    } else
      throw Be;
  }
  return {
    mutate: Rt,
    get data() {
      return se.data = true, Me;
    },
    get error() {
      return se.error = true, Be;
    },
    get isValidating() {
      return se.isValidating = true, He;
    },
    get isLoading() {
      return se.isLoading = true, st;
    }
  };
};
var _t = Qo(ea);
var _e = /* @__PURE__ */ Object.create(null);
_e.open = "0";
_e.close = "1";
_e.ping = "2";
_e.pong = "3";
_e.message = "4";
_e.upgrade = "5";
_e.noop = "6";
var qt = /* @__PURE__ */ Object.create(null);
Object.keys(_e).forEach((n) => {
  qt[_e[n]] = n;
});
var An = { type: "error", data: "parser error" };
var ps = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var ys = typeof ArrayBuffer == "function";
var ms = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer;
var $n = ({ type: n, data: e }, t, r) => ps && e instanceof Blob ? t ? r(e) : Sr(e, r) : ys && (e instanceof ArrayBuffer || ms(e)) ? t ? r(e) : Sr(new Blob([e]), r) : r(_e[n] + (e || ""));
var Sr = (n, e) => {
  const t = new FileReader();
  return t.onload = function() {
    const r = t.result.split(",")[1];
    e("b" + (r || ""));
  }, t.readAsDataURL(n);
};
function Rr(n) {
  return n instanceof Uint8Array ? n : n instanceof ArrayBuffer ? new Uint8Array(n) : new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
}
var mn;
function ta(n, e) {
  if (ps && n.data instanceof Blob)
    return n.data.arrayBuffer().then(Rr).then(e);
  if (ys && (n.data instanceof ArrayBuffer || ms(n.data)))
    return e(Rr(n.data));
  $n(n, false, (t) => {
    mn || (mn = new TextEncoder()), e(mn.encode(t));
  });
}
var Tr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var ht = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let n = 0; n < Tr.length; n++)
  ht[Tr.charCodeAt(n)] = n;
var na = (n) => {
  let e = n.length * 0.75, t = n.length, r, s = 0, i, o, c, l;
  n[n.length - 1] === "=" && (e--, n[n.length - 2] === "=" && e--);
  const a = new ArrayBuffer(e), f = new Uint8Array(a);
  for (r = 0; r < t; r += 4)
    i = ht[n.charCodeAt(r)], o = ht[n.charCodeAt(r + 1)], c = ht[n.charCodeAt(r + 2)], l = ht[n.charCodeAt(r + 3)], f[s++] = i << 2 | o >> 4, f[s++] = (o & 15) << 4 | c >> 2, f[s++] = (c & 3) << 6 | l & 63;
  return a;
};
var ra = typeof ArrayBuffer == "function";
var Wn = (n, e) => {
  if (typeof n != "string")
    return {
      type: "message",
      data: gs(n, e)
    };
  const t = n.charAt(0);
  return t === "b" ? {
    type: "message",
    data: sa(n.substring(1), e)
  } : qt[t] ? n.length > 1 ? {
    type: qt[t],
    data: n.substring(1)
  } : {
    type: qt[t]
  } : An;
};
var sa = (n, e) => {
  if (ra) {
    const t = na(n);
    return gs(t, e);
  } else
    return { base64: true, data: n };
};
var gs = (n, e) => {
  switch (e) {
    case "blob":
      return n instanceof Blob ? n : new Blob([n]);
    case "arraybuffer":
    default:
      return n instanceof ArrayBuffer ? n : n.buffer;
  }
};
var vs = String.fromCharCode(30);
var ia = (n, e) => {
  const t = n.length, r = new Array(t);
  let s = 0;
  n.forEach((i, o) => {
    $n(i, false, (c) => {
      r[o] = c, ++s === t && e(r.join(vs));
    });
  });
};
var oa = (n, e) => {
  const t = n.split(vs), r = [];
  for (let s = 0; s < t.length; s++) {
    const i = Wn(t[s], e);
    if (r.push(i), i.type === "error")
      break;
  }
  return r;
};
function aa() {
  return new TransformStream({
    transform(n, e) {
      ta(n, (t) => {
        const r = t.length;
        let s;
        if (r < 126)
          s = new Uint8Array(1), new DataView(s.buffer).setUint8(0, r);
        else if (r < 65536) {
          s = new Uint8Array(3);
          const i = new DataView(s.buffer);
          i.setUint8(0, 126), i.setUint16(1, r);
        } else {
          s = new Uint8Array(9);
          const i = new DataView(s.buffer);
          i.setUint8(0, 127), i.setBigUint64(1, BigInt(r));
        }
        n.data && typeof n.data != "string" && (s[0] |= 128), e.enqueue(s), e.enqueue(t);
      });
    }
  });
}
var gn;
function Lt(n) {
  return n.reduce((e, t) => e + t.length, 0);
}
function Ft(n, e) {
  if (n[0].length === e)
    return n.shift();
  const t = new Uint8Array(e);
  let r = 0;
  for (let s = 0; s < e; s++)
    t[s] = n[0][r++], r === n[0].length && (n.shift(), r = 0);
  return n.length && r < n[0].length && (n[0] = n[0].slice(r)), t;
}
function ca(n, e) {
  gn || (gn = new TextDecoder());
  const t = [];
  let r = 0, s = -1, i = false;
  return new TransformStream({
    transform(o, c) {
      for (t.push(o); ; ) {
        if (r === 0) {
          if (Lt(t) < 1)
            break;
          const l = Ft(t, 1);
          i = (l[0] & 128) === 128, s = l[0] & 127, s < 126 ? r = 3 : s === 126 ? r = 1 : r = 2;
        } else if (r === 1) {
          if (Lt(t) < 2)
            break;
          const l = Ft(t, 2);
          s = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), r = 3;
        } else if (r === 2) {
          if (Lt(t) < 8)
            break;
          const l = Ft(t, 8), a = new DataView(l.buffer, l.byteOffset, l.length), f = a.getUint32(0);
          if (f > Math.pow(2, 53 - 32) - 1) {
            c.enqueue(An);
            break;
          }
          s = f * Math.pow(2, 32) + a.getUint32(4), r = 3;
        } else {
          if (Lt(t) < s)
            break;
          const l = Ft(t, s);
          c.enqueue(Wn(i ? l : gn.decode(l), e)), r = 0;
        }
        if (s === 0 || s > n) {
          c.enqueue(An);
          break;
        }
      }
    }
  });
}
var ws = 4;
function Y(n) {
  if (n)
    return ua(n);
}
function ua(n) {
  for (var e in Y.prototype)
    n[e] = Y.prototype[e];
  return n;
}
Y.prototype.on = Y.prototype.addEventListener = function(n, e) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + n] = this._callbacks["$" + n] || []).push(e), this;
};
Y.prototype.once = function(n, e) {
  function t() {
    this.off(n, t), e.apply(this, arguments);
  }
  return t.fn = e, this.on(n, t), this;
};
Y.prototype.off = Y.prototype.removeListener = Y.prototype.removeAllListeners = Y.prototype.removeEventListener = function(n, e) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var t = this._callbacks["$" + n];
  if (!t)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + n], this;
  for (var r, s = 0; s < t.length; s++)
    if (r = t[s], r === e || r.fn === e) {
      t.splice(s, 1);
      break;
    }
  return t.length === 0 && delete this._callbacks["$" + n], this;
};
Y.prototype.emit = function(n) {
  this._callbacks = this._callbacks || {};
  for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + n], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  if (t) {
    t = t.slice(0);
    for (var r = 0, s = t.length; r < s; ++r)
      t[r].apply(this, e);
  }
  return this;
};
Y.prototype.emitReserved = Y.prototype.emit;
Y.prototype.listeners = function(n) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + n] || [];
};
Y.prototype.hasListeners = function(n) {
  return !!this.listeners(n).length;
};
var le = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function bs(n, ...e) {
  return e.reduce((t, r) => (n.hasOwnProperty(r) && (t[r] = n[r]), t), {});
}
var la = le.setTimeout;
var fa = le.clearTimeout;
function Qt(n, e) {
  e.useNativeTimers ? (n.setTimeoutFn = la.bind(le), n.clearTimeoutFn = fa.bind(le)) : (n.setTimeoutFn = le.setTimeout.bind(le), n.clearTimeoutFn = le.clearTimeout.bind(le));
}
var ha = 1.33;
function da(n) {
  return typeof n == "string" ? pa(n) : Math.ceil((n.byteLength || n.size) * ha);
}
function pa(n) {
  let e = 0, t = 0;
  for (let r = 0, s = n.length; r < s; r++)
    e = n.charCodeAt(r), e < 128 ? t += 1 : e < 2048 ? t += 2 : e < 55296 || e >= 57344 ? t += 3 : (r++, t += 4);
  return t;
}
function ya(n) {
  let e = "";
  for (let t in n)
    n.hasOwnProperty(t) && (e.length && (e += "&"), e += encodeURIComponent(t) + "=" + encodeURIComponent(n[t]));
  return e;
}
function ma(n) {
  let e = {}, t = n.split("&");
  for (let r = 0, s = t.length; r < s; r++) {
    let i = t[r].split("=");
    e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]);
  }
  return e;
}
var ga = class extends Error {
  constructor(e, t, r) {
    super(e), this.description = t, this.context = r, this.type = "TransportError";
  }
};
var Hn = class extends Y {
  constructor(e) {
    super(), this.writable = false, Qt(this, e), this.opts = e, this.query = e.query, this.socket = e.socket;
  }
  onError(e, t, r) {
    return super.emitReserved("error", new ga(e, t, r)), this;
  }
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  send(e) {
    this.readyState === "open" && this.write(e);
  }
  onOpen() {
    this.readyState = "open", this.writable = true, super.emitReserved("open");
  }
  onData(e) {
    const t = Wn(e, this.socket.binaryType);
    this.onPacket(t);
  }
  onPacket(e) {
    super.emitReserved("packet", e);
  }
  onClose(e) {
    this.readyState = "closed", super.emitReserved("close", e);
  }
  pause(e) {
  }
  createUri(e, t = {}) {
    return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(t);
  }
  _hostname() {
    const e = this.opts.hostname;
    return e.indexOf(":") === -1 ? e : "[" + e + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(e) {
    const t = ya(e);
    return t.length ? "?" + t : "";
  }
};
var _s = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
var Cn = 64;
var va = {};
var Or = 0;
var Pt = 0;
var xr;
function Ar(n) {
  let e = "";
  do
    e = _s[n % Cn] + e, n = Math.floor(n / Cn);
  while (n > 0);
  return e;
}
function Es() {
  const n = Ar(+/* @__PURE__ */ new Date());
  return n !== xr ? (Or = 0, xr = n) : n + "." + Ar(Or++);
}
for (; Pt < Cn; Pt++)
  va[_s[Pt]] = Pt;
var Ss = false;
try {
  Ss = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
var wa = Ss;
function Rs(n) {
  const e = n.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!e || wa))
      return new XMLHttpRequest();
  } catch {
  }
  if (!e)
    try {
      return new le[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function ba() {
}
var _a = function() {
  return new Rs({
    xdomain: false
  }).responseType != null;
}();
var Ea = class extends Hn {
  constructor(e) {
    if (super(e), this.polling = false, typeof location < "u") {
      const r = location.protocol === "https:";
      let s = location.port;
      s || (s = r ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || s !== e.port;
    }
    const t = e && e.forceBase64;
    this.supportsBinary = _a && !t, this.opts.withCredentials && (this.cookieJar = void 0);
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(e) {
    this.readyState = "pausing";
    const t = () => {
      this.readyState = "paused", e();
    };
    if (this.polling || !this.writable) {
      let r = 0;
      this.polling && (r++, this.once("pollComplete", function() {
        --r || t();
      })), this.writable || (r++, this.once("drain", function() {
        --r || t();
      }));
    } else
      t();
  }
  poll() {
    this.polling = true, this.doPoll(), this.emitReserved("poll");
  }
  onData(e) {
    const t = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), false;
      this.onPacket(r);
    };
    oa(e, this.socket.binaryType).forEach(t), this.readyState !== "closed" && (this.polling = false, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  doClose() {
    const e = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e() : this.once("open", e);
  }
  write(e) {
    this.writable = false, ia(e, (t) => {
      this.doWrite(t, () => {
        this.writable = true, this.emitReserved("drain");
      });
    });
  }
  uri() {
    const e = this.opts.secure ? "https" : "http", t = this.query || {};
    return this.opts.timestampRequests !== false && (t[this.opts.timestampParam] = Es()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.createUri(e, t);
  }
  request(e = {}) {
    return Object.assign(e, { xd: this.xd, cookieJar: this.cookieJar }, this.opts), new be(this.uri(), e);
  }
  doWrite(e, t) {
    const r = this.request({
      method: "POST",
      data: e
    });
    r.on("success", t), r.on("error", (s, i) => {
      this.onError("xhr post error", s, i);
    });
  }
  doPoll() {
    const e = this.request();
    e.on("data", this.onData.bind(this)), e.on("error", (t, r) => {
      this.onError("xhr poll error", t, r);
    }), this.pollXhr = e;
  }
};
var be = class _be extends Y {
  constructor(e, t) {
    super(), Qt(this, t), this.opts = t, this.method = t.method || "GET", this.uri = e, this.data = t.data !== void 0 ? t.data : null, this.create();
  }
  create() {
    var e;
    const t = bs(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    t.xdomain = !!this.opts.xd;
    const r = this.xhr = new Rs(t);
    try {
      r.open(this.method, this.uri, true);
      try {
        if (this.opts.extraHeaders) {
          r.setDisableHeaderCheck && r.setDisableHeaderCheck(true);
          for (let s in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(s) && r.setRequestHeader(s, this.opts.extraHeaders[s]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          r.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        r.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (e = this.opts.cookieJar) === null || e === void 0 || e.addCookies(r), "withCredentials" in r && (r.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (r.timeout = this.opts.requestTimeout), r.onreadystatechange = () => {
        var s;
        r.readyState === 3 && ((s = this.opts.cookieJar) === null || s === void 0 || s.parseCookies(r)), r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof r.status == "number" ? r.status : 0);
        }, 0));
      }, r.send(this.data);
    } catch (s) {
      this.setTimeoutFn(() => {
        this.onError(s);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = _be.requestsCount++, _be.requests[this.index] = this);
  }
  onError(e) {
    this.emitReserved("error", e, this.xhr), this.cleanup(true);
  }
  cleanup(e) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = ba, e)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete _be.requests[this.index], this.xhr = null;
    }
  }
  onLoad() {
    const e = this.xhr.responseText;
    e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this.cleanup());
  }
  abort() {
    this.cleanup();
  }
};
be.requestsCount = 0;
be.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", Cr);
  else if (typeof addEventListener == "function") {
    const n = "onpagehide" in le ? "pagehide" : "unload";
    addEventListener(n, Cr, false);
  }
}
function Cr() {
  for (let n in be.requests)
    be.requests.hasOwnProperty(n) && be.requests[n].abort();
}
var Jn = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (e) => Promise.resolve().then(e) : (e, t) => t(e, 0))();
var Bt = le.WebSocket || le.MozWebSocket;
var Dr = true;
var Sa = "arraybuffer";
var kr = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
var Ra = class extends Hn {
  constructor(e) {
    super(e), this.supportsBinary = !e.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const e = this.uri(), t = this.opts.protocols, r = kr ? {} : bs(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = Dr && !kr ? t ? new Bt(e, t) : new Bt(e) : new Bt(e, t, r);
    } catch (s) {
      return this.emitReserved("error", s);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (e) => this.onClose({
      description: "websocket connection closed",
      context: e
    }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(e) {
    this.writable = false;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], s = t === e.length - 1;
      $n(r, this.supportsBinary, (i) => {
        const o = {};
        try {
          Dr && this.ws.send(i);
        } catch {
        }
        s && Jn(() => {
          this.writable = true, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  uri() {
    const e = this.opts.secure ? "wss" : "ws", t = this.query || {};
    return this.opts.timestampRequests && (t[this.opts.timestampParam] = Es()), this.supportsBinary || (t.b64 = 1), this.createUri(e, t);
  }
  check() {
    return !!Bt;
  }
};
var Ta = class extends Hn {
  get name() {
    return "webtransport";
  }
  doOpen() {
    typeof WebTransport == "function" && (this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]), this.transport.closed.then(() => {
      this.onClose();
    }).catch((e) => {
      this.onError("webtransport error", e);
    }), this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((e) => {
        const t = ca(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r = e.readable.pipeThrough(t).getReader(), s = aa();
        s.readable.pipeTo(e.writable), this.writer = s.writable.getWriter();
        const i = () => {
          r.read().then(({ done: c, value: l }) => {
            c || (this.onPacket(l), i());
          }).catch((c) => {
          });
        };
        i();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this.writer.write(o).then(() => this.onOpen());
      });
    }));
  }
  write(e) {
    this.writable = false;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], s = t === e.length - 1;
      this.writer.write(r).then(() => {
        s && Jn(() => {
          this.writable = true, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var e;
    (e = this.transport) === null || e === void 0 || e.close();
  }
};
var Oa = {
  websocket: Ra,
  webtransport: Ta,
  polling: Ea
};
var xa = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var Aa = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function Dn(n) {
  const e = n, t = n.indexOf("["), r = n.indexOf("]");
  t != -1 && r != -1 && (n = n.substring(0, t) + n.substring(t, r).replace(/:/g, ";") + n.substring(r, n.length));
  let s = xa.exec(n || ""), i = {}, o = 14;
  for (; o--; )
    i[Aa[o]] = s[o] || "";
  return t != -1 && r != -1 && (i.source = e, i.host = i.host.substring(1, i.host.length - 1).replace(/;/g, ":"), i.authority = i.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), i.ipv6uri = true), i.pathNames = Ca(i, i.path), i.queryKey = Da(i, i.query), i;
}
function Ca(n, e) {
  const t = /\/{2,9}/g, r = e.replace(t, "/").split("/");
  return (e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1), e.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function Da(n, e) {
  const t = {};
  return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, s, i) {
    s && (t[s] = i);
  }), t;
}
var Ne = class _Ne extends Y {
  constructor(e, t = {}) {
    super(), this.binaryType = Sa, this.writeBuffer = [], e && typeof e == "object" && (t = e, e = null), e ? (e = Dn(e), t.hostname = e.host, t.secure = e.protocol === "https" || e.protocol === "wss", t.port = e.port, e.query && (t.query = e.query)) : t.host && (t.hostname = Dn(t.host).host), Qt(this, t), this.secure = t.secure != null ? t.secure : typeof location < "u" && location.protocol === "https:", t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = t.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = t.transports || [
      "polling",
      "websocket",
      "webtransport"
    ], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = ma(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, false)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, false))), this.open();
  }
  createTransport(e) {
    const t = Object.assign({}, this.opts.query);
    t.EIO = ws, t.transport = e, this.id && (t.sid = this.id);
    const r = Object.assign({}, this.opts, {
      query: t,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[e]);
    return new Oa[e](r);
  }
  open() {
    let e;
    if (this.opts.rememberUpgrade && _Ne.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      e = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      e = this.transports[0];
    this.readyState = "opening";
    try {
      e = this.createTransport(e);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    e.open(), this.setTransport(e);
  }
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (t) => this.onClose("transport close", t));
  }
  probe(e) {
    let t = this.createTransport(e), r = false;
    _Ne.priorWebsocketSuccess = false;
    const s = () => {
      r || (t.send([{ type: "ping", data: "probe" }]), t.once("packet", (h) => {
        if (!r)
          if (h.type === "pong" && h.data === "probe") {
            if (this.upgrading = true, this.emitReserved("upgrading", t), !t)
              return;
            _Ne.priorWebsocketSuccess = t.name === "websocket", this.transport.pause(() => {
              r || this.readyState !== "closed" && (f(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), t = null, this.upgrading = false, this.flush());
            });
          } else {
            const g = new Error("probe error");
            g.transport = t.name, this.emitReserved("upgradeError", g);
          }
      }));
    };
    function i() {
      r || (r = true, f(), t.close(), t = null);
    }
    const o = (h) => {
      const g = new Error("probe error: " + h);
      g.transport = t.name, i(), this.emitReserved("upgradeError", g);
    };
    function c() {
      o("transport closed");
    }
    function l() {
      o("socket closed");
    }
    function a(h) {
      t && h.name !== t.name && i();
    }
    const f = () => {
      t.removeListener("open", s), t.removeListener("error", o), t.removeListener("close", c), this.off("close", l), this.off("upgrading", a);
    };
    t.once("open", s), t.once("error", o), t.once("close", c), this.once("close", l), this.once("upgrading", a), this.upgrades.indexOf("webtransport") !== -1 && e !== "webtransport" ? this.setTimeoutFn(() => {
      r || t.open();
    }, 200) : t.open();
  }
  onOpen() {
    if (this.readyState = "open", _Ne.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) {
      let e = 0;
      const t = this.upgrades.length;
      for (; e < t; e++)
        this.probe(this.upgrades[e]);
    }
  }
  onPacket(e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), this.resetPingTimeout(), e.type) {
        case "open":
          this.onHandshake(JSON.parse(e.data));
          break;
        case "ping":
          this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const t = new Error("server error");
          t.code = e.data, this.onError(t);
          break;
        case "message":
          this.emitReserved("data", e.data), this.emitReserved("message", e.data);
          break;
      }
  }
  onHandshake(e) {
    this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const e = this.getWritablePackets();
      this.transport.send(e), this.prevBufferLen = e.length, this.emitReserved("flush");
    }
  }
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let t = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const s = this.writeBuffer[r].data;
      if (s && (t += da(s)), r > 0 && t > this.maxPayload)
        return this.writeBuffer.slice(0, r);
      t += 2;
    }
    return this.writeBuffer;
  }
  write(e, t, r) {
    return this.sendPacket("message", e, t, r), this;
  }
  send(e, t, r) {
    return this.sendPacket("message", e, t, r), this;
  }
  sendPacket(e, t, r, s) {
    if (typeof t == "function" && (s = t, t = void 0), typeof r == "function" && (s = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== false;
    const i = {
      type: e,
      data: t,
      options: r
    };
    this.emitReserved("packetCreate", i), this.writeBuffer.push(i), s && this.once("flush", s), this.flush();
  }
  close() {
    const e = () => {
      this.onClose("forced close"), this.transport.close();
    }, t = () => {
      this.off("upgrade", t), this.off("upgradeError", t), e();
    }, r = () => {
      this.once("upgrade", t), this.once("upgradeError", t);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : e();
    }) : this.upgrading ? r() : e()), this;
  }
  onError(e) {
    _Ne.priorWebsocketSuccess = false, this.emitReserved("error", e), this.onClose("transport error", e);
  }
  onClose(e, t) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, false), removeEventListener("offline", this.offlineEventListener, false)), this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  filterUpgrades(e) {
    const t = [];
    let r = 0;
    const s = e.length;
    for (; r < s; r++)
      ~this.transports.indexOf(e[r]) && t.push(e[r]);
    return t;
  }
};
Ne.protocol = ws;
function ka(n, e = "", t) {
  let r = n;
  t = t || typeof location < "u" && location, n == null && (n = t.protocol + "//" + t.host), typeof n == "string" && (n.charAt(0) === "/" && (n.charAt(1) === "/" ? n = t.protocol + n : n = t.host + n), /^(https?|wss?):\/\//.test(n) || (typeof t < "u" ? n = t.protocol + "//" + n : n = "https://" + n), r = Dn(n)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const i = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + i + ":" + r.port + e, r.href = r.protocol + "://" + i + (t && t.port === r.port ? "" : ":" + r.port), r;
}
var Na = typeof ArrayBuffer == "function";
var La = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer;
var Ts = Object.prototype.toString;
var Fa = typeof Blob == "function" || typeof Blob < "u" && Ts.call(Blob) === "[object BlobConstructor]";
var Pa = typeof File == "function" || typeof File < "u" && Ts.call(File) === "[object FileConstructor]";
function zn(n) {
  return Na && (n instanceof ArrayBuffer || La(n)) || Fa && n instanceof Blob || Pa && n instanceof File;
}
function Vt(n, e) {
  if (!n || typeof n != "object")
    return false;
  if (Array.isArray(n)) {
    for (let t = 0, r = n.length; t < r; t++)
      if (Vt(n[t]))
        return true;
    return false;
  }
  if (zn(n))
    return true;
  if (n.toJSON && typeof n.toJSON == "function" && arguments.length === 1)
    return Vt(n.toJSON(), true);
  for (const t in n)
    if (Object.prototype.hasOwnProperty.call(n, t) && Vt(n[t]))
      return true;
  return false;
}
function Ba(n) {
  const e = [], t = n.data, r = n;
  return r.data = kn(t, e), r.attachments = e.length, { packet: r, buffers: e };
}
function kn(n, e) {
  if (!n)
    return n;
  if (zn(n)) {
    const t = { _placeholder: true, num: e.length };
    return e.push(n), t;
  } else if (Array.isArray(n)) {
    const t = new Array(n.length);
    for (let r = 0; r < n.length; r++)
      t[r] = kn(n[r], e);
    return t;
  } else if (typeof n == "object" && !(n instanceof Date)) {
    const t = {};
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = kn(n[r], e));
    return t;
  }
  return n;
}
function Ua(n, e) {
  return n.data = Nn(n.data, e), delete n.attachments, n;
}
function Nn(n, e) {
  if (!n)
    return n;
  if (n && n._placeholder === true) {
    if (typeof n.num == "number" && n.num >= 0 && n.num < e.length)
      return e[n.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(n))
    for (let t = 0; t < n.length; t++)
      n[t] = Nn(n[t], e);
  else if (typeof n == "object")
    for (const t in n)
      Object.prototype.hasOwnProperty.call(n, t) && (n[t] = Nn(n[t], e));
  return n;
}
var Ia = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
];
var ja = 5;
var T;
(function(n) {
  n[n.CONNECT = 0] = "CONNECT", n[n.DISCONNECT = 1] = "DISCONNECT", n[n.EVENT = 2] = "EVENT", n[n.ACK = 3] = "ACK", n[n.CONNECT_ERROR = 4] = "CONNECT_ERROR", n[n.BINARY_EVENT = 5] = "BINARY_EVENT", n[n.BINARY_ACK = 6] = "BINARY_ACK";
})(T || (T = {}));
var qa = class {
  constructor(e) {
    this.replacer = e;
  }
  encode(e) {
    return (e.type === T.EVENT || e.type === T.ACK) && Vt(e) ? this.encodeAsBinary({
      type: e.type === T.EVENT ? T.BINARY_EVENT : T.BINARY_ACK,
      nsp: e.nsp,
      data: e.data,
      id: e.id
    }) : [this.encodeAsString(e)];
  }
  encodeAsString(e) {
    let t = "" + e.type;
    return (e.type === T.BINARY_EVENT || e.type === T.BINARY_ACK) && (t += e.attachments + "-"), e.nsp && e.nsp !== "/" && (t += e.nsp + ","), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data, this.replacer)), t;
  }
  encodeAsBinary(e) {
    const t = Ba(e), r = this.encodeAsString(t.packet), s = t.buffers;
    return s.unshift(r), s;
  }
};
function Nr(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
var Kn = class _Kn extends Y {
  constructor(e) {
    super(), this.reviver = e;
  }
  add(e) {
    let t;
    if (typeof e == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      t = this.decodeString(e);
      const r = t.type === T.BINARY_EVENT;
      r || t.type === T.BINARY_ACK ? (t.type = r ? T.EVENT : T.ACK, this.reconstructor = new Va(t), t.attachments === 0 && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t);
    } else if (zn(e) || e.base64)
      if (this.reconstructor)
        t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + e);
  }
  decodeString(e) {
    let t = 0;
    const r = {
      type: Number(e.charAt(0))
    };
    if (T[r.type] === void 0)
      throw new Error("unknown packet type " + r.type);
    if (r.type === T.BINARY_EVENT || r.type === T.BINARY_ACK) {
      const i = t + 1;
      for (; e.charAt(++t) !== "-" && t != e.length; )
        ;
      const o = e.substring(i, t);
      if (o != Number(o) || e.charAt(t) !== "-")
        throw new Error("Illegal attachments");
      r.attachments = Number(o);
    }
    if (e.charAt(t + 1) === "/") {
      const i = t + 1;
      for (; ++t && !(e.charAt(t) === "," || t === e.length); )
        ;
      r.nsp = e.substring(i, t);
    } else
      r.nsp = "/";
    const s = e.charAt(t + 1);
    if (s !== "" && Number(s) == s) {
      const i = t + 1;
      for (; ++t; ) {
        const o = e.charAt(t);
        if (o == null || Number(o) != o) {
          --t;
          break;
        }
        if (t === e.length)
          break;
      }
      r.id = Number(e.substring(i, t + 1));
    }
    if (e.charAt(++t)) {
      const i = this.tryParse(e.substr(t));
      if (_Kn.isPayloadValid(r.type, i))
        r.data = i;
      else
        throw new Error("invalid payload");
    }
    return r;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch {
      return false;
    }
  }
  static isPayloadValid(e, t) {
    switch (e) {
      case T.CONNECT:
        return Nr(t);
      case T.DISCONNECT:
        return t === void 0;
      case T.CONNECT_ERROR:
        return typeof t == "string" || Nr(t);
      case T.EVENT:
      case T.BINARY_EVENT:
        return Array.isArray(t) && (typeof t[0] == "number" || typeof t[0] == "string" && Ia.indexOf(t[0]) === -1);
      case T.ACK:
      case T.BINARY_ACK:
        return Array.isArray(t);
    }
  }
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
};
var Va = class {
  constructor(e) {
    this.packet = e, this.buffers = [], this.reconPack = e;
  }
  takeBinaryData(e) {
    if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
      const t = Ua(this.reconPack, this.buffers);
      return this.finishedReconstruction(), t;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
};
var Ma = Object.freeze(Object.defineProperty({
  __proto__: null,
  protocol: ja,
  get PacketType() {
    return T;
  },
  Encoder: qa,
  Decoder: Kn
}, Symbol.toStringTag, { value: "Module" }));
function de(n, e, t) {
  return n.on(e, t), function() {
    n.off(e, t);
  };
}
var $a = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
var Os = class extends Y {
  constructor(e, t, r) {
    super(), this.connected = false, this.recovered = false, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const e = this.io;
    this.subs = [
      de(e, "open", this.onopen.bind(this)),
      de(e, "packet", this.onpacket.bind(this)),
      de(e, "error", this.onerror.bind(this)),
      de(e, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  open() {
    return this.connect();
  }
  send(...e) {
    return e.unshift("message"), this.emit.apply(this, e), this;
  }
  emit(e, ...t) {
    if ($a.hasOwnProperty(e))
      throw new Error('"' + e.toString() + '" is a reserved event name');
    if (t.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(t), this;
    const r = {
      type: T.EVENT,
      data: t
    };
    if (r.options = {}, r.options.compress = this.flags.compress !== false, typeof t[t.length - 1] == "function") {
      const o = this.ids++, c = t.pop();
      this._registerAckCallback(o, c), r.id = o;
    }
    const s = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!s || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;
  }
  _registerAckCallback(e, t) {
    var r;
    const s = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
    if (s === void 0) {
      this.acks[e] = t;
      return;
    }
    const i = this.io.setTimeoutFn(() => {
      delete this.acks[e];
      for (let o = 0; o < this.sendBuffer.length; o++)
        this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1);
      t.call(this, new Error("operation has timed out"));
    }, s);
    this.acks[e] = (...o) => {
      this.io.clearTimeoutFn(i), t.apply(this, [null, ...o]);
    };
  }
  emitWithAck(e, ...t) {
    const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((s, i) => {
      t.push((o, c) => r ? o ? i(o) : s(c) : s(o)), this.emit(e, ...t);
    });
  }
  _addToQueue(e) {
    let t;
    typeof e[e.length - 1] == "function" && (t = e.pop());
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args: e,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    e.push((s, ...i) => r !== this._queue[0] ? void 0 : (s !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), t && t(s)) : (this._queue.shift(), t && t(null, ...i)), r.pending = false, this._drainQueue())), this._queue.push(r), this._drainQueue();
  }
  _drainQueue(e = false) {
    if (!this.connected || this._queue.length === 0)
      return;
    const t = this._queue[0];
    t.pending && !e || (t.pending = true, t.tryCount++, this.flags = t.flags, this.emit.apply(this, t.args));
  }
  packet(e) {
    e.nsp = this.nsp, this.io._packet(e);
  }
  onopen() {
    typeof this.auth == "function" ? this.auth((e) => {
      this._sendConnectPacket(e);
    }) : this._sendConnectPacket(this.auth);
  }
  _sendConnectPacket(e) {
    this.packet({
      type: T.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e
    });
  }
  onerror(e) {
    this.connected || this.emitReserved("connect_error", e);
  }
  onclose(e, t) {
    this.connected = false, delete this.id, this.emitReserved("disconnect", e, t);
  }
  onpacket(e) {
    if (e.nsp === this.nsp)
      switch (e.type) {
        case T.CONNECT:
          e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case T.EVENT:
        case T.BINARY_EVENT:
          this.onevent(e);
          break;
        case T.ACK:
        case T.BINARY_ACK:
          this.onack(e);
          break;
        case T.DISCONNECT:
          this.ondisconnect();
          break;
        case T.CONNECT_ERROR:
          this.destroy();
          const r = new Error(e.data.message);
          r.data = e.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  onevent(e) {
    const t = e.data || [];
    e.id != null && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const t = this._anyListeners.slice();
      for (const r of t)
        r.apply(this, e);
    }
    super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]);
  }
  ack(e) {
    const t = this;
    let r = false;
    return function(...s) {
      r || (r = true, t.packet({
        type: T.ACK,
        id: e,
        data: s
      }));
    };
  }
  onack(e) {
    const t = this.acks[e.id];
    typeof t == "function" && (t.apply(this, e.data), delete this.acks[e.id]);
  }
  onconnect(e, t) {
    this.id = e, this.recovered = t && this._pid === t, this._pid = t, this.connected = true, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(true);
  }
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {
      this.notifyOutgoingListeners(e), this.packet(e);
    }), this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);
  }
  disconnect() {
    return this.connected && this.packet({ type: T.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  close() {
    return this.disconnect();
  }
  compress(e) {
    return this.flags.compress = e, this;
  }
  get volatile() {
    return this.flags.volatile = true, this;
  }
  timeout(e) {
    return this.flags.timeout = e, this;
  }
  onAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;
  }
  prependAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;
  }
  offAny(e) {
    if (!this._anyListeners)
      return this;
    if (e) {
      const t = this._anyListeners;
      for (let r = 0; r < t.length; r++)
        if (e === t[r])
          return t.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;
  }
  prependAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;
  }
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners)
      return this;
    if (e) {
      const t = this._anyOutgoingListeners;
      for (let r = 0; r < t.length; r++)
        if (e === t[r])
          return t.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const t = this._anyOutgoingListeners.slice();
      for (const r of t)
        r.apply(this, e.data);
    }
  }
};
function et(n) {
  n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0;
}
et.prototype.duration = function() {
  var n = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(), t = Math.floor(e * this.jitter * n);
    n = (Math.floor(e * 10) & 1) == 0 ? n - t : n + t;
  }
  return Math.min(n, this.max) | 0;
};
et.prototype.reset = function() {
  this.attempts = 0;
};
et.prototype.setMin = function(n) {
  this.ms = n;
};
et.prototype.setMax = function(n) {
  this.max = n;
};
et.prototype.setJitter = function(n) {
  this.jitter = n;
};
var Ln = class extends Y {
  constructor(e, t) {
    var r;
    super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (t = e, e = void 0), t = t || {}, t.path = t.path || "/socket.io", this.opts = t, Qt(this, t), this.reconnection(t.reconnection !== false), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor((r = t.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new et({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e;
    const s = t.parser || Ma;
    this.encoder = new s.Encoder(), this.decoder = new s.Decoder(), this._autoConnect = t.autoConnect !== false, this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length ? (this._reconnection = !!e, this) : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);
  }
  reconnectionDelay(e) {
    var t;
    return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this);
  }
  randomizationFactor(e) {
    var t;
    return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this);
  }
  reconnectionDelayMax(e) {
    var t;
    return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this);
  }
  timeout(e) {
    return arguments.length ? (this._timeout = e, this) : this._timeout;
  }
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  open(e) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Ne(this.uri, this.opts);
    const t = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = false;
    const s = de(t, "open", function() {
      r.onopen(), e && e();
    }), i = (c) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", c), e ? e(c) : this.maybeReconnectOnOpen();
    }, o = de(t, "error", i);
    if (this._timeout !== false) {
      const c = this._timeout, l = this.setTimeoutFn(() => {
        s(), i(new Error("timeout")), t.close();
      }, c);
      this.opts.autoUnref && l.unref(), this.subs.push(() => {
        this.clearTimeoutFn(l);
      });
    }
    return this.subs.push(s), this.subs.push(o), this;
  }
  connect(e) {
    return this.open(e);
  }
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const e = this.engine;
    this.subs.push(de(e, "ping", this.onping.bind(this)), de(e, "data", this.ondata.bind(this)), de(e, "error", this.onerror.bind(this)), de(e, "close", this.onclose.bind(this)), de(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(e) {
    try {
      this.decoder.add(e);
    } catch (t) {
      this.onclose("parse error", t);
    }
  }
  ondecoded(e) {
    Jn(() => {
      this.emitReserved("packet", e);
    }, this.setTimeoutFn);
  }
  onerror(e) {
    this.emitReserved("error", e);
  }
  socket(e, t) {
    let r = this.nsps[e];
    return r ? this._autoConnect && !r.active && r.connect() : (r = new Os(this, e, t), this.nsps[e] = r), r;
  }
  _destroy(e) {
    const t = Object.keys(this.nsps);
    for (const r of t)
      if (this.nsps[r].active)
        return;
    this._close();
  }
  _packet(e) {
    const t = this.encoder.encode(e);
    for (let r = 0; r < t.length; r++)
      this.engine.write(t[r], e.options);
  }
  cleanup() {
    this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = true, this._reconnecting = false, this.onclose("forced close"), this.engine && this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(e, t) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = false;
    else {
      const t = this.backoff.duration();
      this._reconnecting = true;
      const r = this.setTimeoutFn(() => {
        e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open((s) => {
          s ? (e._reconnecting = false, e.reconnect(), this.emitReserved("reconnect_error", s)) : e.onreconnect();
        }));
      }, t);
      this.opts.autoUnref && r.unref(), this.subs.push(() => {
        this.clearTimeoutFn(r);
      });
    }
  }
  onreconnect() {
    const e = this.backoff.attempts;
    this._reconnecting = false, this.backoff.reset(), this.emitReserved("reconnect", e);
  }
};
var ut = {};
function Mt(n, e) {
  typeof n == "object" && (e = n, n = void 0), e = e || {};
  const t = ka(n, e.path || "/socket.io"), r = t.source, s = t.id, i = t.path, o = ut[s] && i in ut[s].nsps, c = e.forceNew || e["force new connection"] || e.multiplex === false || o;
  let l;
  return c ? l = new Ln(r, e) : (ut[s] || (ut[s] = new Ln(r, e)), l = ut[s]), t.query && !e.query && (e.query = t.queryKey), l.socket(t.path, e);
}
Object.assign(Mt, {
  Manager: Ln,
  Socket: Os,
  io: Mt,
  connect: Mt
});
var Wa = class {
  constructor(e, t, r, s) {
    De(this, "socket_port");
    De(this, "host");
    De(this, "port");
    De(this, "protocol");
    De(this, "url");
    De(this, "site_name");
    De(this, "socket");
    var i, o, c;
    if (this.socket_port = r != null ? r : "9000", this.host = (i = window.location) == null ? void 0 : i.hostname, this.port = (o = window.location) != null && o.port ? `:${this.socket_port}` : "", this.protocol = this.port ? "http" : "https", e) {
      let l = new URL(e);
      l.port = "", r ? (l.port = r, this.url = l.toString()) : this.url = l.toString();
    } else
      this.url = `${this.protocol}://${this.host}${this.port}/`;
    t && (this.url = `${this.url}${t}`), this.site_name = t, this.socket = Mt(`${this.url}`, {
      withCredentials: true,
      secure: this.protocol === "https",
      extraHeaders: s && s.useToken === true ? {
        Authorization: `${s.type} ${(c = s.token) == null ? void 0 : c.call(s)}`
      } : {}
    });
  }
};
var xs = { exports: {} };
var ft = {};
var Fr;
function Ja() {
  return Fr || (Fr = 1, function() {
    var n = import_react.default, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), c = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), a = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), p = Symbol.iterator, y = "@@iterator";
    function E(u) {
      if (u === null || typeof u != "object")
        return null;
      var m = p && u[p] || u[y];
      return typeof m == "function" ? m : null;
    }
    var b = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function R(u) {
      {
        for (var m = arguments.length, w = new Array(m > 1 ? m - 1 : 0), _ = 1; _ < m; _++)
          w[_ - 1] = arguments[_];
        O("error", u, w);
      }
    }
    function O(u, m, w) {
      {
        var _ = b.ReactDebugCurrentFrame, N = _.getStackAddendum();
        N !== "" && (m += "%s", w = w.concat([N]));
        var j = w.map(function(A) {
          return String(A);
        });
        j.unshift("Warning: " + m), Function.prototype.apply.call(console[u], console, j);
      }
    }
    var x = false, L = false, k = false, re = false, P = false, W;
    W = Symbol.for("react.module.reference");
    function Q(u) {
      return !!(typeof u == "string" || typeof u == "function" || u === r || u === i || P || u === s || u === a || u === f || re || u === v || x || L || k || typeof u == "object" && u !== null && (u.$$typeof === g || u.$$typeof === h || u.$$typeof === o || u.$$typeof === c || u.$$typeof === l || u.$$typeof === W || u.getModuleId !== void 0));
    }
    function pe(u, m, w) {
      var _ = u.displayName;
      if (_)
        return _;
      var N = m.displayName || m.name || "";
      return N !== "" ? w + "(" + N + ")" : w;
    }
    function ye(u) {
      return u.displayName || "Context";
    }
    function M(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && R("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case r:
          return "Fragment";
        case t:
          return "Portal";
        case i:
          return "Profiler";
        case s:
          return "StrictMode";
        case a:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case c:
            var m = u;
            return ye(m) + ".Consumer";
          case o:
            var w = u;
            return ye(w._context) + ".Provider";
          case l:
            return pe(u, u.render, "ForwardRef");
          case h:
            var _ = u.displayName || null;
            return _ !== null ? _ : M(u.type) || "Memo";
          case g: {
            var N = u, j = N._payload, A = N._init;
            try {
              return M(A(j));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var se = Object.assign, Pe = 0, tt, nt, Se, rt, Et, Re, Te;
    function Be() {
    }
    Be.__reactDisabledLog = true;
    function St() {
      {
        if (Pe === 0) {
          tt = console.log, nt = console.info, Se = console.warn, rt = console.error, Et = console.group, Re = console.groupCollapsed, Te = console.groupEnd;
          var u = {
            configurable: true,
            enumerable: true,
            value: Be,
            writable: true
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        Pe++;
      }
    }
    function Me() {
      {
        if (Pe--, Pe === 0) {
          var u = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: se({}, u, {
              value: tt
            }),
            info: se({}, u, {
              value: nt
            }),
            warn: se({}, u, {
              value: Se
            }),
            error: se({}, u, {
              value: rt
            }),
            group: se({}, u, {
              value: Et
            }),
            groupCollapsed: se({}, u, {
              value: Re
            }),
            groupEnd: se({}, u, {
              value: Te
            })
          });
        }
        Pe < 0 && R("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var $e = b.ReactCurrentDispatcher, We;
    function He(u, m, w) {
      {
        if (We === void 0)
          try {
            throw Error();
          } catch (N) {
            var _ = N.stack.trim().match(/\n( *(at )?)/);
            We = _ && _[1] || "";
          }
        return `
` + We + u;
      }
    }
    var st = false, me;
    {
      var Rt = typeof WeakMap == "function" ? WeakMap : Map;
      me = new Rt();
    }
    function B(u, m) {
      if (!u || st)
        return "";
      {
        var w = me.get(u);
        if (w !== void 0)
          return w;
      }
      var _;
      st = true;
      var N = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var j;
      j = $e.current, $e.current = null, St();
      try {
        if (m) {
          var A = function() {
            throw Error();
          };
          if (Object.defineProperty(A.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(A, []);
            } catch (xe) {
              _ = xe;
            }
            Reflect.construct(u, [], A);
          } else {
            try {
              A.call();
            } catch (xe) {
              _ = xe;
            }
            u.call(A.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (xe) {
            _ = xe;
          }
          u();
        }
      } catch (xe) {
        if (xe && _ && typeof xe.stack == "string") {
          for (var S = xe.stack.split(`
`), ne = _.stack.split(`
`), $ = S.length - 1, z = ne.length - 1; $ >= 1 && z >= 0 && S[$] !== ne[z]; )
            z--;
          for (; $ >= 1 && z >= 0; $--, z--)
            if (S[$] !== ne[z]) {
              if ($ !== 1 || z !== 1)
                do
                  if ($--, z--, z < 0 || S[$] !== ne[z]) {
                    var ce = `
` + S[$].replace(" at new ", " at ");
                    return u.displayName && ce.includes("<anonymous>") && (ce = ce.replace("<anonymous>", u.displayName)), typeof u == "function" && me.set(u, ce), ce;
                  }
                while ($ >= 1 && z >= 0);
              break;
            }
        }
      } finally {
        st = false, $e.current = j, Me(), Error.prepareStackTrace = N;
      }
      var Ye = u ? u.displayName || u.name : "", rr = Ye ? He(Ye) : "";
      return typeof u == "function" && me.set(u, rr), rr;
    }
    function I(u, m, w) {
      return B(u, false);
    }
    function X(u) {
      var m = u.prototype;
      return !!(m && m.isReactComponent);
    }
    function q(u, m, w) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return B(u, X(u));
      if (typeof u == "string")
        return He(u);
      switch (u) {
        case a:
          return He("Suspense");
        case f:
          return He("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case l:
            return I(u.render);
          case h:
            return q(u.type, m, w);
          case g: {
            var _ = u, N = _._payload, j = _._init;
            try {
              return q(j(N), m, w);
            } catch {
            }
          }
        }
      return "";
    }
    var te = Object.prototype.hasOwnProperty, Oe = {}, H = b.ReactDebugCurrentFrame;
    function J(u) {
      if (u) {
        var m = u._owner, w = q(u.type, u._source, m ? m.type : null);
        H.setExtraStackFrame(w);
      } else
        H.setExtraStackFrame(null);
    }
    function he(u, m, w, _, N) {
      {
        var j = Function.call.bind(te);
        for (var A in u)
          if (j(u, A)) {
            var S = void 0;
            try {
              if (typeof u[A] != "function") {
                var ne = Error((_ || "React class") + ": " + w + " type `" + A + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[A] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ne.name = "Invariant Violation", ne;
              }
              S = u[A](m, A, _, w, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch ($) {
              S = $;
            }
            S && !(S instanceof Error) && (J(N), R("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", _ || "React class", w, A, typeof S), J(null)), S instanceof Error && !(S.message in Oe) && (Oe[S.message] = true, J(N), R("Failed %s type: %s", w, S.message), J(null));
          }
      }
    }
    var Tt = Array.isArray;
    function Je(u) {
      return Tt(u);
    }
    function Ot(u) {
      {
        var m = typeof Symbol == "function" && Symbol.toStringTag, w = m && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return w;
      }
    }
    function ie(u) {
      try {
        return ae(u), false;
      } catch {
        return true;
      }
    }
    function ae(u) {
      return "" + u;
    }
    function ze(u) {
      if (ie(u))
        return R("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ot(u)), ae(u);
    }
    var Ue = b.ReactCurrentOwner, it = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, Yn, Gn, Zt;
    Zt = {};
    function Ds(u) {
      if (te.call(u, "ref")) {
        var m = Object.getOwnPropertyDescriptor(u, "ref").get;
        if (m && m.isReactWarning)
          return false;
      }
      return u.ref !== void 0;
    }
    function ks(u) {
      if (te.call(u, "key")) {
        var m = Object.getOwnPropertyDescriptor(u, "key").get;
        if (m && m.isReactWarning)
          return false;
      }
      return u.key !== void 0;
    }
    function Ns(u, m) {
      if (typeof u.ref == "string" && Ue.current && m && Ue.current.stateNode !== m) {
        var w = M(Ue.current.type);
        Zt[w] || (R('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', M(Ue.current.type), u.ref), Zt[w] = true);
      }
    }
    function Ls(u, m) {
      {
        var w = function() {
          Yn || (Yn = true, R("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", m));
        };
        w.isReactWarning = true, Object.defineProperty(u, "key", {
          get: w,
          configurable: true
        });
      }
    }
    function Fs(u, m) {
      {
        var w = function() {
          Gn || (Gn = true, R("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", m));
        };
        w.isReactWarning = true, Object.defineProperty(u, "ref", {
          get: w,
          configurable: true
        });
      }
    }
    var Ps = function(u, m, w, _, N, j, A) {
      var S = {
        $$typeof: e,
        type: u,
        key: m,
        ref: w,
        props: A,
        _owner: j
      };
      return S._store = {}, Object.defineProperty(S._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(S, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: _
      }), Object.defineProperty(S, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: N
      }), Object.freeze && (Object.freeze(S.props), Object.freeze(S)), S;
    };
    function Bs(u, m, w, _, N) {
      {
        var j, A = {}, S = null, ne = null;
        w !== void 0 && (ze(w), S = "" + w), ks(m) && (ze(m.key), S = "" + m.key), Ds(m) && (ne = m.ref, Ns(m, N));
        for (j in m)
          te.call(m, j) && !it.hasOwnProperty(j) && (A[j] = m[j]);
        if (u && u.defaultProps) {
          var $ = u.defaultProps;
          for (j in $)
            A[j] === void 0 && (A[j] = $[j]);
        }
        if (S || ne) {
          var z = typeof u == "function" ? u.displayName || u.name || "Unknown" : u;
          S && Ls(A, z), ne && Fs(A, z);
        }
        return Ps(u, S, ne, N, _, Ue.current, A);
      }
    }
    var en = b.ReactCurrentOwner, Xn = b.ReactDebugCurrentFrame;
    function Ke(u) {
      if (u) {
        var m = u._owner, w = q(u.type, u._source, m ? m.type : null);
        Xn.setExtraStackFrame(w);
      } else
        Xn.setExtraStackFrame(null);
    }
    var tn;
    tn = false;
    function nn(u) {
      return typeof u == "object" && u !== null && u.$$typeof === e;
    }
    function Qn() {
      {
        if (en.current) {
          var u = M(en.current.type);
          if (u)
            return `

Check the render method of \`` + u + "`.";
        }
        return "";
      }
    }
    function Us(u) {
      {
        if (u !== void 0) {
          var m = u.fileName.replace(/^.*[\\\/]/, ""), w = u.lineNumber;
          return `

Check your code at ` + m + ":" + w + ".";
        }
        return "";
      }
    }
    var Zn = {};
    function Is(u) {
      {
        var m = Qn();
        if (!m) {
          var w = typeof u == "string" ? u : u.displayName || u.name;
          w && (m = `

Check the top-level render call using <` + w + ">.");
        }
        return m;
      }
    }
    function er(u, m) {
      {
        if (!u._store || u._store.validated || u.key != null)
          return;
        u._store.validated = true;
        var w = Is(m);
        if (Zn[w])
          return;
        Zn[w] = true;
        var _ = "";
        u && u._owner && u._owner !== en.current && (_ = " It was passed a child from " + M(u._owner.type) + "."), Ke(u), R('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', w, _), Ke(null);
      }
    }
    function tr(u, m) {
      {
        if (typeof u != "object")
          return;
        if (Je(u))
          for (var w = 0; w < u.length; w++) {
            var _ = u[w];
            nn(_) && er(_, m);
          }
        else if (nn(u))
          u._store && (u._store.validated = true);
        else if (u) {
          var N = E(u);
          if (typeof N == "function" && N !== u.entries)
            for (var j = N.call(u), A; !(A = j.next()).done; )
              nn(A.value) && er(A.value, m);
        }
      }
    }
    function js(u) {
      {
        var m = u.type;
        if (m == null || typeof m == "string")
          return;
        var w;
        if (typeof m == "function")
          w = m.propTypes;
        else if (typeof m == "object" && (m.$$typeof === l || m.$$typeof === h))
          w = m.propTypes;
        else
          return;
        if (w) {
          var _ = M(m);
          he(w, u.props, "prop", _, u);
        } else if (m.PropTypes !== void 0 && !tn) {
          tn = true;
          var N = M(m);
          R("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", N || "Unknown");
        }
        typeof m.getDefaultProps == "function" && !m.getDefaultProps.isReactClassApproved && R("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function qs(u) {
      {
        for (var m = Object.keys(u.props), w = 0; w < m.length; w++) {
          var _ = m[w];
          if (_ !== "children" && _ !== "key") {
            Ke(u), R("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", _), Ke(null);
            break;
          }
        }
        u.ref !== null && (Ke(u), R("Invalid attribute `ref` supplied to `React.Fragment`."), Ke(null));
      }
    }
    function nr(u, m, w, _, N, j) {
      {
        var A = Q(u);
        if (!A) {
          var S = "";
          (u === void 0 || typeof u == "object" && u !== null && Object.keys(u).length === 0) && (S += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ne = Us(N);
          ne ? S += ne : S += Qn();
          var $;
          u === null ? $ = "null" : Je(u) ? $ = "array" : u !== void 0 && u.$$typeof === e ? ($ = "<" + (M(u.type) || "Unknown") + " />", S = " Did you accidentally export a JSX literal instead of a component?") : $ = typeof u, R("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", $, S);
        }
        var z = Bs(u, m, w, N, j);
        if (z == null)
          return z;
        if (A) {
          var ce = m.children;
          if (ce !== void 0)
            if (_)
              if (Je(ce)) {
                for (var Ye = 0; Ye < ce.length; Ye++)
                  tr(ce[Ye], u);
                Object.freeze && Object.freeze(ce);
              } else
                R("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              tr(ce, u);
        }
        return u === r ? qs(z) : js(z), z;
      }
    }
    function Vs(u, m, w) {
      return nr(u, m, w, true);
    }
    function Ms(u, m, w) {
      return nr(u, m, w, false);
    }
    var $s = Ms, Ws = Vs;
    ft.Fragment = r, ft.jsx = $s, ft.jsxs = Ws;
  }()), ft;
}
(function(n) {
  false ? n.exports = Ha() : n.exports = Ja();
})(xs);
var za = xs.exports.jsx;
var ee = (0, import_react.createContext)(null);
var Za = ({
  url: n = "",
  tokenParams: e,
  socketPort: t,
  siteName: r,
  enableSocket: s = true,
  children: i
}) => {
  const o = (0, import_react.useMemo)(() => {
    const c = new So.FrappeApp(n, e);
    return {
      url: n,
      tokenParams: e,
      app: c,
      auth: c.auth(),
      db: c.db(),
      call: c.call(),
      file: c.file(),
      socket: s ? new Wa(n, r, t, e).socket : void 0,
      enableSocket: s,
      socketPort: t
    };
  }, [n, e, t, s]);
  return za(ee.Provider, {
    value: o,
    children: i
  });
};
var ec = (n) => {
  const {
    url: e,
    auth: t,
    tokenParams: r
  } = (0, import_react.useContext)(ee), [s, i] = (0, import_react.useState)(), o = (0, import_react.useCallback)(() => {
    const p = document.cookie.split(";").find((y) => y.trim().startsWith("user_id="));
    if (p) {
      const y = p.split("=")[1];
      i(y && y !== "Guest" ? y : null);
    } else
      i(null);
  }, []);
  (0, import_react.useEffect)(() => {
    r && r.useToken ? i(null) : o();
  }, []);
  const {
    data: c,
    error: l,
    isLoading: a,
    isValidating: f,
    mutate: h
  } = _t(() => r && r.useToken || s ? `${e}/api/method/frappe.auth.get_logged_user` : null, () => t.getLoggedInUser(), {
    onError: () => {
      i(null);
    },
    shouldRetryOnError: false,
    revalidateOnFocus: false,
    ...n
  }), g = (0, import_react.useCallback)(async (p) => t.loginWithUsernamePassword(p).then((y) => (o(), y)), []), v = (0, import_react.useCallback)(async () => t.logout().then(() => h(null)).then(() => i(null)), []);
  return {
    isLoading: s === void 0 || a,
    currentUser: c,
    isValidating: f,
    error: l,
    login: g,
    logout: v,
    updateCurrentUser: h,
    getUserCookie: o
  };
};
var As = (n, e, t) => {
  let r = `${e}/api/resource/`;
  return t ? r += `${n}/${t}` : r += `${n}`, r;
};
var tc = (n, e, t, r) => {
  const {
    url: s,
    db: i
  } = (0, import_react.useContext)(ee);
  return {
    ..._t(t === void 0 ? As(n, s, e) : t, () => i.getDoc(n, e), r)
  };
};
var Ka = (n) => {
  var t, r, s;
  let e = "";
  if (n != null && n.fields && (e += "fields=" + JSON.stringify(n == null ? void 0 : n.fields) + "&"), n != null && n.filters && (e += "filters=" + JSON.stringify(n == null ? void 0 : n.filters) + "&"), n != null && n.orFilters && (e += "or_filters=" + JSON.stringify(n == null ? void 0 : n.orFilters) + "&"), n != null && n.limit_start && (e += "limit_start=" + JSON.stringify(n == null ? void 0 : n.limit_start) + "&"), n != null && n.limit && (e += "limit=" + JSON.stringify(n == null ? void 0 : n.limit) + "&"), n != null && n.groupBy && (e += "group_by=" + String(n.groupBy) + "&"), n != null && n.orderBy) {
    const i = `${String((t = n.orderBy) == null ? void 0 : t.field)} ${(s = (r = n.orderBy) == null ? void 0 : r.order) != null ? s : "asc"}`;
    e += "order_by=" + i + "&";
  }
  return n != null && n.asDict && (e += "as_dict=" + n.asDict), e;
};
var nc = (n, e, t, r) => {
  const {
    url: s,
    db: i
  } = (0, import_react.useContext)(ee);
  return {
    ..._t(t === void 0 ? `${As(n, s)}?${Ka(e)}` : t, () => i.getDocList(n, e), r)
  };
};
var rc = () => {
  const {
    db: n
  } = (0, import_react.useContext)(ee), [e, t] = (0, import_react.useState)(false), [r, s] = (0, import_react.useState)(null), [i, o] = (0, import_react.useState)(false), c = (0, import_react.useCallback)(() => {
    t(false), s(null), o(false);
  }, []);
  return {
    createDoc: (0, import_react.useCallback)(async (a, f) => (s(null), o(false), t(true), n.createDoc(a, f).then((h) => (t(false), o(true), h)).catch((h) => {
      throw t(false), o(false), s(h), h;
    })), []),
    loading: e,
    error: r,
    isCompleted: i,
    reset: c
  };
};
var sc = () => {
  const {
    db: n
  } = (0, import_react.useContext)(ee), [e, t] = (0, import_react.useState)(false), [r, s] = (0, import_react.useState)(null), [i, o] = (0, import_react.useState)(false), c = (0, import_react.useCallback)(() => {
    t(false), s(null), o(false);
  }, []);
  return {
    updateDoc: (0, import_react.useCallback)(async (a, f, h) => (s(null), o(false), t(true), n.updateDoc(a, f, h).then((g) => (t(false), o(true), g)).catch((g) => {
      throw t(false), o(false), s(g), g;
    })), []),
    loading: e,
    error: r,
    reset: c,
    isCompleted: i
  };
};
var ic = () => {
  const {
    db: n
  } = (0, import_react.useContext)(ee), [e, t] = (0, import_react.useState)(false), [r, s] = (0, import_react.useState)(null), [i, o] = (0, import_react.useState)(false), c = (0, import_react.useCallback)(() => {
    t(false), s(null), o(false);
  }, []);
  return {
    deleteDoc: (0, import_react.useCallback)(async (a, f) => (s(null), o(false), t(true), n.deleteDoc(a, f).then((h) => (t(false), o(true), h)).catch((h) => {
      throw t(false), o(false), s(h), h;
    })), []),
    loading: e,
    error: r,
    reset: c,
    isCompleted: i
  };
};
function Cs(n) {
  const e = [];
  for (let t in n)
    e.push(encodeURIComponent(t) + "=" + encodeURIComponent(n[t]));
  return e.join("&");
}
var oc = (n, e, t = false, r = false, s, i) => {
  const {
    url: o,
    db: c
  } = (0, import_react.useContext)(ee);
  return {
    ..._t(s === void 0 ? (() => {
      const f = Cs(t ? {
        doctype: n,
        filters: e != null ? e : [],
        cache: t,
        debug: r
      } : {
        doctype: n,
        filters: e != null ? e : [],
        debug: r
      });
      return `${o}/api/method/frappe.client.get_count?${f}`;
    })() : s, () => c.getCount(n, e, t, r), i)
  };
};
var Ya = (n, e, t, r) => {
  const {
    call: s
  } = (0, import_react.useContext)(ee), i = Cs(e != null ? e : {}), o = `${n}?${i}`;
  return {
    ..._t(t === void 0 ? o : t, () => s.get(n, e), r)
  };
};
var ac = (n) => {
  const {
    call: e
  } = (0, import_react.useContext)(ee), [t, r] = (0, import_react.useState)(null), [s, i] = (0, import_react.useState)(false), [o, c] = (0, import_react.useState)(null), [l, a] = (0, import_react.useState)(false), f = (0, import_react.useCallback)(() => {
    r(null), i(false), c(null), a(false);
  }, []);
  return {
    call: (0, import_react.useCallback)(async (g) => (c(null), a(false), i(true), r(null), e.post(n, g).then((v) => (r(v), i(false), a(true), v)).catch((v) => {
      throw i(false), a(false), c(v), v;
    })), []),
    result: t,
    loading: s,
    error: o,
    reset: f,
    isCompleted: l
  };
};
var cc = (n) => {
  const {
    call: e
  } = (0, import_react.useContext)(ee), [t, r] = (0, import_react.useState)(null), [s, i] = (0, import_react.useState)(false), [o, c] = (0, import_react.useState)(null), [l, a] = (0, import_react.useState)(false), f = (0, import_react.useCallback)(() => {
    r(null), i(false), c(null), a(false);
  }, []);
  return {
    call: (0, import_react.useCallback)(async (g) => (c(null), a(false), i(true), r(null), e.put(n, g).then((v) => (r(v), i(false), a(true), v)).catch((v) => {
      throw i(false), a(false), c(v), v;
    })), []),
    result: t,
    loading: s,
    error: o,
    reset: f,
    isCompleted: l
  };
};
var uc = (n) => {
  const {
    call: e
  } = (0, import_react.useContext)(ee), [t, r] = (0, import_react.useState)(null), [s, i] = (0, import_react.useState)(false), [o, c] = (0, import_react.useState)(null), [l, a] = (0, import_react.useState)(false), f = (0, import_react.useCallback)(() => {
    r(null), i(false), c(null), a(false);
  }, []);
  return {
    call: (0, import_react.useCallback)(async (g) => (c(null), a(false), i(true), r(null), e.delete(n, g).then((v) => (r(v), i(false), a(true), v)).catch((v) => {
      throw i(false), a(false), c(v), v;
    })), []),
    result: t,
    loading: s,
    error: o,
    reset: f,
    isCompleted: l
  };
};
var lc = () => {
  const {
    file: n
  } = (0, import_react.useContext)(ee), [e, t] = (0, import_react.useState)(0), [r, s] = (0, import_react.useState)(false), [i, o] = (0, import_react.useState)(null), [c, l] = (0, import_react.useState)(false), a = (0, import_react.useCallback)(async (h, g, v) => (f(), s(true), n.uploadFile(h, g, (p, y) => {
    y && t(Math.round(p / y * 100));
  }, v).then((p) => (l(true), t(100), s(false), p.data.message)).catch((p) => {
    throw console.error(p), o(p), s(false), p;
  })), []), f = (0, import_react.useCallback)(() => {
    t(0), s(false), o(null), l(false);
  }, []);
  return {
    upload: a,
    progress: e,
    loading: r,
    isCompleted: c,
    error: i,
    reset: f
  };
};
var fc = (n, e, t = [], r = 20, s = 250) => {
  const i = Ga(e, s);
  return Ya("frappe.desk.search.search_link", {
    doctype: n,
    page_length: r,
    txt: i,
    filters: JSON.stringify(t != null ? t : [])
  });
};
var Ga = (n, e) => {
  const [t, r] = (0, import_react.useState)(n);
  return (0, import_react.useEffect)(() => {
    const s = setTimeout(() => {
      r(n);
    }, e);
    return () => {
      clearTimeout(s);
    };
  }, [n, e]), t;
};
var Fn = (n, e) => {
  const {
    socket: t
  } = (0, import_react.useContext)(ee);
  (0, import_react.useEffect)(() => {
    t === void 0 && console.warn("Socket is not enabled. Please enable socket in FrappeProvider.");
    let r = t == null ? void 0 : t.on(n, e);
    return () => {
      r == null || r.off(n);
    };
  }, [n, e]);
};
var hc = (n, e, t, r = true) => {
  const {
    socket: s
  } = (0, import_react.useContext)(ee), [i, o] = (0, import_react.useState)([]);
  (0, import_react.useEffect)(() => (s === void 0 && console.warn("Socket is not enabled. Please enable socket in FrappeProvider."), s == null || s.emit("doc_subscribe", n, e), r && (s == null || s.emit("doc_open", n, e)), () => {
    s == null || s.emit("doc_unsubscribe", n, e), r && (s == null || s.emit("doc_close", n, e));
  }), [n, e, r]), Fn("doc_update", t);
  const c = (0, import_react.useCallback)(() => {
    s == null || s.emit("doc_open", n, e);
  }, [n, e]), l = (0, import_react.useCallback)(() => {
    s == null || s.emit("doc_close", n, e);
  }, [n, e]), a = (0, import_react.useCallback)((f) => {
    f.doctype === n && f.docname === e && o(f.users);
  }, [n, e]);
  return Fn("doc_viewers", a), {
    viewers: i,
    emitDocOpen: c,
    emitDocClose: l
  };
};
var dc = (n, e) => {
  const {
    socket: t
  } = (0, import_react.useContext)(ee);
  (0, import_react.useEffect)(() => (t === void 0 && console.warn("Socket is not enabled. Please enable socket in FrappeProvider."), t == null || t.emit("doctype_subscribe", n), () => {
    t == null || t.emit("doctype_unsubscribe", n);
  }), [n]), Fn("list_update", e);
};
export {
  ee as FrappeContext,
  Za as FrappeProvider,
  Ka as getDocListQueryString,
  As as getRequestURL,
  ec as useFrappeAuth,
  rc as useFrappeCreateDoc,
  uc as useFrappeDeleteCall,
  ic as useFrappeDeleteDoc,
  dc as useFrappeDocTypeEventListener,
  hc as useFrappeDocumentEventListener,
  Fn as useFrappeEventListener,
  lc as useFrappeFileUpload,
  Ya as useFrappeGetCall,
  tc as useFrappeGetDoc,
  oc as useFrappeGetDocCount,
  nc as useFrappeGetDocList,
  ac as useFrappePostCall,
  cc as useFrappePutCall,
  sc as useFrappeUpdateDoc,
  _t as useSWR,
  Yo as useSWRConfig,
  fc as useSearch
};
/*! Bundled license information:

frappe-react-sdk/dist/frappe-react-sdk.es.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

frappe-react-sdk/dist/frappe-react-sdk.es.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

frappe-react-sdk/dist/frappe-react-sdk.es.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

frappe-react-sdk/dist/frappe-react-sdk.es.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=frappe-react-sdk.js.map
